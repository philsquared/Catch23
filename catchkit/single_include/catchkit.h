/*
 * CatchKit
 * Single header - Generated: 2025-07-26 16:32:26.064069
 * ----------------------------------------------------------
 * This file has been generated by merging together multiple source files.
 * Please don't edit it directly.
 *
 * Distributed under the MIT license. See text reproduced, below:
 *
 * Copyright 2025 Phil Nash
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
 * associated documentation files (the “Software”), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE
 */
#ifndef CATCHKIT_PACKED_H_INCLUDED
#define CATCHKIT_PACKED_H_INCLUDED

// Packed header

// System includes:
#include <algorithm>
#include <type_traits>
#include <optional>
#include <format>
#include <cmath>
#include <source_location>
#include <print>
#include <exception>
#include <string_view>
#include <utility>
#include <cassert>
#include <sstream>
#include <string>
#include <vector>

// From header files:

// Packed from catchkit/include/catchkit/result_type.h
namespace CatchKit {

    enum class ResultType {
        Unknown,
        Pass,
        ExpressionFailed,
        MatchFailed,
        UnexpectedException,
        MissingException
    };

} // namespace CatchKit


// Packed from catchkit/include/catchkit/operators.h
namespace CatchKit::Detail {

    enum class Operators {
        None,
        Equals,
        NotEqualTo,
        GreaterThan,
        LessThan,
        GreaterThanOrEqual,
        LessThanOrEqual
    };

} // namespace CatchKit::Detail


// Packed from catchkit/include/catchkit/expression_info.h
namespace CatchKit::Detail {

    struct ExpressionInfo
    {
        std::string lhs;
        std::string rhs;

        Operators op;
        std::string_view op_str;
    };

} // namespace CatchKit::Detail

namespace CatchKit {

    using Detail::ExpressionInfo;

}

template<>
struct std::formatter<CatchKit::Detail::ExpressionInfo> {
    constexpr auto parse(std::format_parse_context& ctx) { return ctx.begin(); }
    std::format_context::iterator format(const CatchKit::Detail::ExpressionInfo& expr, std::format_context& ctx) const;
};


// Packed from catchkit/include/catchkit/report_on.h
namespace CatchKit {

    enum class ReportOn {
        FailuresOnly,
        AllResults
    };

} // namespace CatchKit


// Packed from catchkit/include/catchkit/result_handler.h
namespace CatchKit::Detail
{
    struct AssertionContext;

    enum class ResultDisposition { Abort, Continue };

    struct ResultHandler {
        ReportOn report_on;

        explicit ResultHandler(ReportOn report_on) : report_on(report_on) {}
        virtual ~ResultHandler();

        virtual void on_assertion_start( ResultDisposition result_disposition, AssertionContext&& context ) = 0;
        virtual void on_assertion_result( ResultType result, std::optional<ExpressionInfo> const& expression_info, std::string_view message ) = 0;
        virtual void on_assertion_end() = 0;
    };

} // namespace CatchKit::Detail

namespace CatchKit
{
    using Detail::ResultDisposition;
}


// Packed from catchkit/include/catchkit/assertion_context.h
namespace CatchKit::Detail {

    struct AssertionContext {
        std::string_view macro_name;
        std::string_view original_expression;
        std::string_view message  = {};
        std::source_location location = std::source_location::current();

        auto combine_messages(std::string_view additional_message) -> std::string;
    };

} // namespace CatchKit::Detail

namespace CatchKit {

    using Detail::AssertionContext;

} // namespace CatchKit


// Packed from catchkit/include/catchkit/assert_result_handler.h
namespace CatchKit::Detail {

    struct AssertResultHandler : ResultHandler {
        AssertionContext current_context;
        ResultType last_result = ResultType::Unknown;
        ResultDisposition result_disposition = ResultDisposition::Abort;

        AssertResultHandler() : ResultHandler(ReportOn::FailuresOnly) {}

        void on_assertion_start( ResultDisposition result_disposition, AssertionContext&& context ) override;
        void on_assertion_result( ResultType result, std::optional<ExpressionInfo> const& expression_info, std::string_view message ) override;
        void on_assertion_end() override;
    };

    void set_current_assertion_handler( AssertResultHandler& handler ); // impl in catchkit_checker.cpp

} // namespace CatchKit::Detail


// Packed from catchkit/include/catchkit/expr_ref.h
namespace CatchKit::Detail {

    struct Asserter;

    // Holds a unary expression - ie just evaluates to a single value
    // Also used for the LHS of a binary expression during decomposition
    template<typename T>
    struct UnaryExprRef {
        T& value;
        Asserter* asserter = nullptr;
        std::string message = {};

        auto evaluate() -> ResultType;
        auto expand( ResultType result ) -> ExpressionInfo;

        ~UnaryExprRef();
    };

    // Holds binary expression
    template<typename LhsT, typename RhsT, Operators Op>
    struct BinaryExprRef {
        LhsT& lhs;
        RhsT& rhs;
        Asserter* asserter = nullptr;
        std::string message = {};

        auto evaluate() -> ResultType;
        auto expand( ResultType result ) -> ExpressionInfo;

        ~BinaryExprRef();
    };

    template<typename ArgT, typename MatcherT>
    struct MatchExprRef {
        ArgT& arg;
        MatcherT const& matcher;
        Asserter* asserter = nullptr;
        std::string message = {};

        auto evaluate() -> ResultType;
        auto expand( ResultType result ) -> ExpressionInfo;

        ~MatchExprRef();
    };

    // Holds the result of a match
    struct MatchResult {
        bool result;
        explicit(false) MatchResult(bool result) : result(result) {}
        explicit operator bool() const { return result; }
    };

} // namespace CatchKit::Detail


// Packed from catchkit/include/catchkit/internal_warnings.h
#if defined(__clang__)
#define CATCHKIT_WARNINGS_SUPPRESS_START                _Pragma( "clang diagnostic push" )
#define CATCHKIT_WARNINGS_SUPPRESS_END                  _Pragma( "clang diagnostic pop" )
#define CATCHKIT_WARNINGS_SUPPRESS_PARENTHESES          _Pragma( "clang diagnostic ignored \"-Wparentheses\"" )
#define CATCHKIT_WARNINGS_SUPPRESS_UNUSED_COMPARISON    _Pragma( "clang diagnostic ignored \"-Wunused-comparison\"" )
#define CATCHKIT_WARNINGS_SUPPRESS_ADDRESS              _Pragma( "clang diagnostic ignored \"-Waddress\"" )
#define CATCHKIT_WARNINGS_SUPPRESS_SIGN_MISMATCH        _Pragma( "clang diagnostic ignored \"-Wsign-compare\"" )
#define CATCHKIT_WARNINGS_SUPPRESS_UNUSED_PARAMETER     _Pragma( "clang diagnostic ignored \"-Wunused-parameter\"" )
#define CATCHKIT_WARNINGS_SUPPRESS_FLOAT_RANGE          _Pragma( "clang diagnostic ignored \"-Wliteral-range\"" )
#define CATCHKIT_WARNINGS_SUPPRESS_NULL_CONVERSION      _Pragma( "clang diagnostic ignored \"-Wnull-conversion\"" )

#elif defined(__GNUC__) && !defined(__ICC) && !defined(__CUDACC__) // GCC
#define CATCHKIT_WARNINGS_SUPPRESS_START                _Pragma( "GCC diagnostic push" )
#define CATCHKIT_WARNINGS_SUPPRESS_END                  _Pragma( "GCC diagnostic pop" )
#define CATCHKIT_WARNINGS_SUPPRESS_PARENTHESES          _Pragma( "GCC diagnostic ignored \"-Wparentheses\"" )
#define CATCHKIT_WARNINGS_SUPPRESS_UNUSED_COMPARISON
#define CATCHKIT_WARNINGS_SUPPRESS_ADDRESS              _Pragma( "GCC diagnostic ignored \"-Waddress\"" )
#define CATCHKIT_WARNINGS_SUPPRESS_SIGN_MISMATCH        _Pragma( "GCC diagnostic ignored \"-Wsign-compare\"" )
#define CATCHKIT_WARNINGS_SUPPRESS_UNUSED_PARAMETER     _Pragma( "GCC diagnostic ignored \"-Wunused-parameter\"" )
#define CATCHKIT_WARNINGS_SUPPRESS_FLOAT_RANGE
#define CATCHKIT_WARNINGS_SUPPRESS_NULL_CONVERSION

#elif define(_MSC_VER)
#define CATCHKIT_WARNINGS_SUPPRESS_START                __pragma( warning(push) )
#define CATCHKIT_WARNINGS_SUPPRESS_END                  __pragma( warning(pop) )
#define CATCHKIT_WARNINGS_SUPPRESS_PARENTHESES
#define CATCHKIT_WARNINGS_SUPPRESS_UNUSED_COMPARISON
#define CATCHKIT_WARNINGS_SUPPRESS_ADDRESS
#define CATCHKIT_WARNINGS_SUPPRESS_SIGN_MISMATCH        __pragma( warning( disable:4389 ) ) __pragma( warning( disable:4018 ) )
#define CATCHKIT_WARNINGS_SUPPRESS_UNUSED_PARAMETER
#define CATCHKIT_WARNINGS_SUPPRESS_FLOAT_RANGE
#define CATCHKIT_WARNINGS_SUPPRESS_NULL_CONVERSION

#else
// !TBD Other compilers
#define CATCHKIT_WARNINGS_SUPPRESS_START
#define CATCHKIT_WARNINGS_SUPPRESS_END
#define CATCHKIT_WARNINGS_SUPPRESS_PARENTHESES
#define CATCHKIT_WARNINGS_SUPPRESS_UNUSED_COMPARISON
#define CATCHKIT_WARNINGS_SUPPRESS_ADDRESS
#define CATCHKIT_WARNINGS_SUPPRESS_UNUSED_PARAMETER
#define CATCHKIT_WARNINGS_SUPPRESS_FLOAT_RANGE
#define CATCHKIT_WARNINGS_SUPPRESS_NULL_CONVERSION

#endif


// Packed from catchkit/include/catchkit/operator_to_string.h
namespace CatchKit::Detail {

    // String conversions for operator enum
    template<Operators op>
    [[nodiscard]] consteval auto operator_to_string() noexcept
    {
        using enum Operators;
        if constexpr( op == Equals )                    return "==";
        else if constexpr( op == NotEqualTo )           return "!=" ;
        else if constexpr( op == GreaterThan )          return ">";
        else if constexpr( op == LessThan )             return "<";
        else if constexpr( op == GreaterThanOrEqual )   return ">=";
        else if constexpr( op == LessThanOrEqual )      return "<=";
        else {
            // Note that while None is a valid enum value, we should never use it on a path that leads here
            static_assert( false, "Unrecognised operator" );
        }
    }

} // namespace CatchKit::Detail


// Packed from catchkit/include/catchkit/decomposer.h
namespace CatchKit::Detail {

    // To decompose a comparison with another value
    template<typename LhsT, typename RhsT> requires requires( LhsT lhs, RhsT rhs ) { lhs == rhs; }
    [[maybe_unused]] constexpr auto operator == ( UnaryExprRef<LhsT>&& lhs, RhsT&& rhs ) noexcept {
        return BinaryExprRef<LhsT, std::remove_reference_t<RhsT>, Operators::Equals>{ lhs.value, rhs, std::exchange(lhs.asserter, nullptr) };
    }
    template<typename LhsT, typename RhsT> requires requires( LhsT lhs, RhsT rhs ) { lhs != rhs; }
    [[maybe_unused]] constexpr auto operator != ( UnaryExprRef<LhsT>&& lhs, RhsT&& rhs ) noexcept {
        return BinaryExprRef<LhsT, std::remove_reference_t<RhsT>, Operators::NotEqualTo>{ lhs.value, rhs, std::exchange(lhs.asserter, nullptr) };
    }
    template<typename LhsT, typename RhsT> requires requires( LhsT lhs, RhsT rhs ) { lhs > rhs; }
    [[maybe_unused]] constexpr auto operator > ( UnaryExprRef<LhsT>&& lhs, RhsT&& rhs ) noexcept {
        return BinaryExprRef<LhsT, std::remove_reference_t<RhsT>, Operators::GreaterThan>{ lhs.value, rhs, std::exchange(lhs.asserter, nullptr) };
    }
    template<typename LhsT, typename RhsT> requires requires( LhsT lhs, RhsT rhs ) { lhs < rhs; }
    [[maybe_unused]] constexpr auto operator < ( UnaryExprRef<LhsT>&& lhs, RhsT&& rhs ) noexcept {
        return BinaryExprRef<LhsT, std::remove_reference_t<RhsT>, Operators::LessThan>{ lhs.value, rhs, std::exchange(lhs.asserter, nullptr) };
    }
    template<typename LhsT, typename RhsT> requires requires( LhsT lhs, RhsT rhs ) { lhs >= rhs; }
    [[maybe_unused]] constexpr auto operator >= ( UnaryExprRef<LhsT>&& lhs, RhsT&& rhs ) noexcept {
        return BinaryExprRef<LhsT, std::remove_reference_t<RhsT>, Operators::GreaterThanOrEqual>{ lhs.value, rhs, std::exchange(lhs.asserter, nullptr) };
    }
    template<typename LhsT, typename RhsT> requires requires( LhsT lhs, RhsT rhs ) { lhs <= rhs; }
    [[maybe_unused]] constexpr auto operator <= ( UnaryExprRef<LhsT>&& lhs, RhsT&& rhs ) noexcept {
        return BinaryExprRef<LhsT, std::remove_reference_t<RhsT>, Operators::LessThanOrEqual>{ lhs.value, rhs, std::exchange(lhs.asserter, nullptr) };
    }

    template<typename ArgT>
    [[maybe_unused]] constexpr auto&& operator, ( UnaryExprRef<ArgT>&& value_ref, std::string_view message ) noexcept {
        value_ref.message = message;
        return value_ref;
    }
    template<typename LhsT, typename RhsT, Operators Op>
    [[maybe_unused]] constexpr auto&& operator, ( BinaryExprRef<LhsT, RhsT, Op>&& expr_ref, std::string_view message ) noexcept {
        expr_ref.message = message;
        return expr_ref;
    }
    template<typename ArgT, typename T>
    [[maybe_unused]] constexpr auto&& operator, ( UnaryExprRef<ArgT>&& expr_ref, std::string_view message ) noexcept {
        expr_ref.message = message;
        return expr_ref;
    }


} // namespace CatchKit::Detail


// Packed from catchkit/include/catchkit/exceptions.h
namespace CatchKit::Detail {

    [[nodiscard]] auto get_exception_message( std::exception_ptr const& ex ) -> std::string;

} // namespace CatchKit::Detail


// Packed from catchkit/include/catchkit/stringify.h
#define CATCHKIT_FALLBACK_TO_FORMAT_STRING_CONVERSIONS
// #define CATCHKIT_FALLBACK_TO_OSTREAM_STRING_CONVERSIONS

#ifdef CATCHKIT_FALLBACK_TO_FORMAT_STRING_CONVERSIONS
#include <format>
#endif
#ifdef CATCHKIT_FALLBACK_TO_OSTREAM_STRING_CONVERSIONS
#include <sstream>
#endif

namespace CatchKit {

    namespace Detail {
        auto pointer_to_string(void const* p) -> std::string;
        void ignore( auto&& ) noexcept {}

        auto parse_enum_name_from_function(std::string_view function_name, bool fully_qualified = false) -> std::string_view;
        auto unknown_enum_to_string(size_t enum_value) -> std::string;

        constexpr size_t enum_probe_start = 0;
        constexpr size_t enum_probe_end = 16;

        template<typename E, E candidate=static_cast<E>(enum_probe_start), size_t max_probe=enum_probe_end>
        struct enum_value_string {
            static auto find(E e) -> std::string_view {
                if( e == candidate )
                    return parse_enum_name_from_function(std::source_location::current().function_name());
                if constexpr(static_cast<size_t>( candidate) < max_probe )
                    return enum_value_string<E, static_cast<E>(static_cast<size_t>(candidate)+1)>::find(e);
                return {};
            }
        };

        template<typename E>
        auto enum_to_string(E e) -> std::string {
            if( auto val = enum_value_string<E>::find(e); !val.empty() )
                return std::string(val);
            return unknown_enum_to_string(static_cast<size_t>(e));
        }

    }

    #ifdef FALLBACK_TO_OSTREAM_STRING_CONVERSIONS
    template <typename T>
    concept Streamable = requires( std::ostream os, T value ) {
        { os << value };
    };
    #endif

    template<typename T>
    struct Stringifier {
        [[nodiscard]] static auto stringify( T const& value ) -> std::string {

            #ifdef FALLBACK_TO_FORMAT_STRING_CONVERSIONS
            if constexpr( std::formattable<T, char> ) {
                return std::format("{}", value);
            }
            #endif

            #ifdef FALLBACK_TO_OSTREAM_STRING_CONVERSIONS
            if constexpr ( Streamable<T> ) {
                std::ostringstream oss; // !TBD: use an ostringstream pool?
                oss << value;
                return oss.str();
            }
            #endif

            #if !defined(FALLBACK_TO_OSTREAM_STRING_CONVERSIONS) && !defined(FALLBACK_TO_FORMAT_STRING_CONVERSIONS)
            Detail::ignore( value );
            #endif

            return "{?}";
        }
    };

    template<>
    struct Stringifier<std::string> {
        [[nodiscard]] static constexpr auto stringify( std::string const& value ) -> std::string { return value; }
        [[nodiscard]] static constexpr auto stringify( std::string&& value ) -> std::string { return std::move(value); }
    };
    template<>
    struct Stringifier<std::string_view> {
        [[nodiscard]] static constexpr auto stringify( std::string_view value ) -> std::string { return std::string( value ); }
    };
    template<>
    struct Stringifier<char const*> {
        [[nodiscard]] static constexpr auto stringify( char const* value ) -> std::string {
            return value ? std::string( value ) : std::string("nullptr");
        }
    };
    template<size_t size>
    struct Stringifier<char[size]> {
        [[nodiscard]] static constexpr auto stringify( char const* value ) -> std::string {
            return value;
        }
    };

    template<typename T>
    requires requires{ !std::same_as<std::decay_t<T>, char>; }
    struct Stringifier<T*> {
        [[nodiscard]] static constexpr auto stringify( T* value ) -> std::string {
            return value ? Detail::pointer_to_string( value ) : std::string("nullptr");
        }
    };

    // !TBD: more conversions of built-ins, including containers
    // - also wait for std::format for ranges to match with that

    // Don't specialise this
    template<typename T>
    [[nodiscard]] auto constexpr stringify(T const& value ) {
        if constexpr( std::same_as<T, bool> )
            return value ? "true" : "false";
        else if constexpr( std::is_enum_v<T> )
            return Detail::enum_to_string( value );
        else if constexpr( std::floating_point<T> || std::integral<T> )
            return std::to_string( value );
        else if constexpr( std::is_null_pointer_v<T> )
            return "nullptr";
        else
            return Stringifier<T>::stringify( value );
    }

} // namespace CatchKit


// Packed from catchkit/include/catchkit/checker.h
namespace CatchKit::Detail
{
    struct Asserter;

    struct Checker {
        ResultHandler& result_handler;
        ResultDisposition result_disposition;
        bool should_decompose = true;

        auto operator()(std::string_view message = {}, std::source_location assertion_location = std::source_location::current()) -> Asserter;
        auto operator()(AssertionContext&& context) -> Asserter;
    };

    struct Asserter {
        Checker& checker;

        ~Asserter() noexcept(false) {
            checker.result_handler.on_assertion_end(); // This may throw to cancel the test
        }
        void handle_unexpected_exceptions(std::invocable<Asserter&> auto const& expr_call) {
            try {
                expr_call(*this);
            }
            catch(...) {
                checker.result_handler.on_assertion_result( ResultType::UnexpectedException, {}, get_exception_message(std::current_exception()) );
            }
        }

        template<typename T>
        void simple_assert(auto const&, T&&) noexcept {
            static_assert(std::is_convertible_v<T, std::string_view>, "Only matchers or strings can follow the comma operator");
        }
        void simple_assert(std::nullptr_t, std::string_view message = {}) noexcept {
            simple_assert(false, message);
        }
        void simple_assert(auto const& result, std::string_view message = {}) noexcept {
            bool is_failure = !result;
            if( checker.result_handler.report_on == ReportOn::AllResults || is_failure ) {}
                checker.result_handler.on_assertion_result(is_failure ? ResultType::ExpressionFailed : ResultType::Pass, {}, message);
        }
        void accept_expr(auto& expr) noexcept; // Implemented after the definitions of the Expr Ref types

        // To kick off an expression decomposition
        template<typename LhsT>
        [[maybe_unused]] friend constexpr auto operator << ( Asserter& asserter, LhsT&& lhs ) noexcept {
            return UnaryExprRef{ lhs, &asserter };
        }
        template<typename LhsT>
        [[maybe_unused]] friend constexpr auto operator << ( Asserter&& asserter, LhsT&& lhs ) noexcept {
            return UnaryExprRef{ lhs, &asserter };
        }
    };

    // --------------

    template<typename T>
    UnaryExprRef<T>::~UnaryExprRef() {
        if( asserter )
            asserter->accept_expr(*this);
    }

    template<typename T>
    auto UnaryExprRef<T>::evaluate() -> ResultType {
        if constexpr( requires (T v){ { !v } -> std::same_as<bool>; }) {
            CATCHKIT_WARNINGS_SUPPRESS_START
            CATCHKIT_WARNINGS_SUPPRESS_ADDRESS
            CATCHKIT_WARNINGS_SUPPRESS_NULL_CONVERSION
            return !value ? ResultType::ExpressionFailed : ResultType::Pass;
            CATCHKIT_WARNINGS_SUPPRESS_END
        }
        else if constexpr( std::is_null_pointer_v<T> ) {
            // Special case for GCC
            return ResultType::ExpressionFailed;
        }
        else {
            // Have to do this at runtime because we can get here from the destructor of a UnaryExpr,
            // even if it doesn't happen at runtime because it's actually a binary expresion
            throw std::logic_error("Attempt to use a value that cannot convert to bool in boolean context");
        }
    }
    template<typename T>
    auto UnaryExprRef<T>::expand(ResultType) -> ExpressionInfo {
        return ExpressionInfo{ {std::string(stringify(value))}, {}, Operators::None, {} };
    }

    template<typename LhsT, typename RhsT, Operators Op>
    BinaryExprRef<LhsT, RhsT, Op>::~BinaryExprRef() {
        if( asserter )
            asserter->accept_expr(*this);
    }

    CATCHKIT_WARNINGS_SUPPRESS_START CATCHKIT_WARNINGS_SUPPRESS_SIGN_MISMATCH
    template<typename LhsT, typename RhsT, Operators Op>
    auto eval_expr(BinaryExprRef<LhsT, RhsT, Op>& expr) {
        using enum Operators;
        if constexpr( Op == Equals )                    return expr.lhs == expr.rhs;
        else if constexpr( Op == NotEqualTo )           return expr.lhs != expr.rhs;
        else if constexpr( Op == GreaterThan )          return expr.lhs >  expr.rhs;
        else if constexpr( Op == LessThan )             return expr.lhs <  expr.rhs;
        else if constexpr( Op == GreaterThanOrEqual )   return expr.lhs >= expr.rhs;
        else if constexpr( Op == LessThanOrEqual )      return expr.lhs <= expr.rhs;
        else {
            // Note that while None is a valid enum value, we should never use it on a path that leads here
            static_assert( false, "Operator not implemented" );
        }
        std::unreachable();
    }
    CATCHKIT_WARNINGS_SUPPRESS_END

    template<typename LhsT, typename RhsT, Operators Op>
    auto BinaryExprRef<LhsT, RhsT, Op>::evaluate() -> ResultType {
        return static_cast<bool>( eval_expr(*this) ) ? ResultType::Pass : ResultType::ExpressionFailed;
    }
    template<typename LhsT, typename RhsT, Operators Op>
    auto BinaryExprRef<LhsT, RhsT, Op>::expand(ResultType) -> ExpressionInfo {
        return ExpressionInfo{
            std::string( stringify(lhs) ),
            std::string( stringify(rhs) ),
            Op,
            operator_to_string<Op>() };
    }

    template<typename ArgT, typename MatcherT>
    MatchExprRef<ArgT, MatcherT>::~MatchExprRef() {
        if( asserter )
            asserter->accept_expr(*this);
    }

    // -------

    void Asserter::accept_expr( auto& expr ) noexcept {
        auto result = expr.evaluate();

        if( checker.result_handler.report_on == ReportOn::AllResults || result != ResultType::Pass ) {
            checker.result_handler.on_assertion_result( result, expr.expand(result), expr.message );
        }
        else {
            checker.result_handler.on_assertion_result( result, {}, expr.message );
        }
    }

} // namespace CatchKit::Detail

namespace CatchKit
{
    using Detail::Checker;

} //namespace CatchKit

// These global instances are used if not using the ones passed in to a function locally
extern constinit CatchKit::Checker check, require;


#define CATCHKIT_ASSERT_INTERNAL(macro_name, checker, ...) \
if(checker.should_decompose) { \
    CATCHKIT_WARNINGS_SUPPRESS_START CATCHKIT_WARNINGS_SUPPRESS_UNUSED_COMPARISON \
    checker(CatchKit::AssertionContext(macro_name, #__VA_ARGS__)).handle_unexpected_exceptions([&](CatchKit::Detail::Asserter& asserter){ asserter << __VA_ARGS__; }); \
    CATCHKIT_WARNINGS_SUPPRESS_END \
} else checker(CatchKit::AssertionContext(macro_name, #__VA_ARGS__)).simple_assert(__VA_ARGS__)


#define CATCHKIT_ASSERT_THAT_INTERNAL(macro_name, checker, arg, match_expr) \
do { using namespace CatchKit::Matchers; \
    checker(CatchKit::AssertionContext(macro_name, #arg ", " #match_expr)) << [&]{ return arg; }, match_expr; \
} while( false )


#define CHECK(...) CATCHKIT_ASSERT_INTERNAL( "CHECK", check, __VA_ARGS__ )
#define REQUIRE(...) CATCHKIT_ASSERT_INTERNAL( "REQUIRE", require, __VA_ARGS__ )

#define CHECK_THAT( arg, matcher ) CATCHKIT_ASSERT_THAT_INTERNAL( "CHECK_THAT", check, arg, matcher )
#define REQUIRE_THAT( arg, matcher ) CATCHKIT_ASSERT_THAT_INTERNAL( "REQUIRE_THAT", require, arg, matcher )

#define REQUIRE_STATIC(...) static_assert(__VA_ARGS__)

// !TBD: These should have a dedicated internal macro (in Catch2 it was INTERNAL_CATCH_MSG)
#define PASS(...) CATCHKIT_ASSERT_INTERNAL( "PASS", check, true __VA_OPT__(,) __VA_ARGS__ )
#define FAIL(...) CATCHKIT_ASSERT_INTERNAL( "FAIL", require, false __VA_OPT__(,) __VA_ARGS__ )



// Packed from catchkit/include/catchkit/matchers.h
namespace CatchKit {

    using Detail::MatchResult;

    namespace Detail {
        struct CouldBeAnything {
            template <typename T> explicit(false) operator T() const;
        };

        // !TBD: This needs a solution for Matchers with overloads of matches
        template<typename M>
        concept IsEagerMatcher = requires(M m, CouldBeAnything something) {
            { m.matches(something) } -> std::same_as<MatchResult>;
        };

        template<typename M>
        concept IsLazyMatcher = requires(M m) {
            { m.matches_lazy([]{}) } -> std::same_as<MatchResult>;
        };

        template<typename M>
        concept IsMatcher = IsEagerMatcher<M> || IsLazyMatcher<M>;

        template<typename M>
        concept MatcherHasDescribeMethod = requires(M const m) {
            { m.describe() } -> std::convertible_to<std::string>;
        };


        template<typename M1, typename M2>
        struct AndMatcher {
            M1& matcher1;
            M2& matcher2;

            MatchResult matches( auto const& value ) const {
                if( auto result = matcher1.matches(value); !result )
                    return result;
                return matcher2.matches(value);
            }
            constexpr auto describe() const {
                return std::format("AndMatcher"); // !TBD
            }
        };

        template<typename M1, typename M2>
        struct OrMatcher {
            M1& matcher1;
            M2& matcher2;

            MatchResult matches( auto const& value ) const {
                // !TBD: combine results?
                if( auto result1 = matcher1.matches(value); result1 )
                    return result1;
                return matcher2.matches(value);
            }
            auto describe() const {
                return std::format("OrMatcher"); // !TBD
            }
        };

        template<typename M>
        struct NotMatcher {
            M& base_matcher;

            MatchResult matches( auto const& value ) const {
                return !base_matcher.matches(value);
            }
            auto describe() const {
                return std::format("NotMatcher"); // !TBD
            }
        };

        template<typename M2>
        auto operator && (IsMatcher auto&& m1, M2&& m2) {
            static_assert(IsMatcher<M2>, "Operand to && is not a matcher");
            return AndMatcher(m1, m2);
        }

        template<typename M2>
        auto operator || (IsMatcher auto&& m1, M2&& m2) {
            static_assert(IsMatcher<M2>, "Operand to || is not a matcher");
            return OrMatcher( m1, m2 );
        }

        auto operator ! (IsMatcher auto&& m) {
            return NotMatcher(m);
        }

        // Invokes the lambda and checks if it throws - potentially if it throws a specific type
        // and optionally converts the exception to a string and returns that.
        template<typename E, bool return_message>
        auto check_throws(auto f) -> std::optional<std::string> {
            if constexpr( std::is_void_v<E> ) {
                try {
                    f();
                }
                catch(...) {
                    if constexpr(return_message)
                        return get_exception_message(std::current_exception());
                    else
                        return {""};
                }
            }
            else {
                try {
                    f();
                }
                catch (E& e) {
                    if constexpr(return_message)
                        return get_exception_message(std::current_exception());
                    else
                        return {""};
                }
                catch (...) {
                    return {};
                }
            }
            return {};
        }

        template<typename ArgT, IsMatcher MatcherT>
        [[maybe_unused]] constexpr auto operator, ( UnaryExprRef<ArgT>&& arg, MatcherT const& matcher ) noexcept {
            static_assert(MatcherHasDescribeMethod<MatcherT>, "Matcher is missing describe method");
            return MatchExprRef{ arg.value, matcher, std::exchange(arg.asserter, nullptr) };
        }

        template<typename ArgT, typename MatcherT>
        [[maybe_unused]] constexpr auto operator, ( MatchExprRef<ArgT, MatcherT>&& matcher_ref, std::string_view message ) noexcept {
            matcher_ref.message = message;
            return matcher_ref;
        }

        template<typename ArgT, typename MatcherT>
        auto MatchExprRef<ArgT, MatcherT>::evaluate() -> ResultType {
            if constexpr( IsLazyMatcher<MatcherT> ) {
                static_assert( std::invocable<ArgT>, "Lazy matchers must be matched against lambdas" );
                return matcher.matches_lazy(arg) ? ResultType::Pass : ResultType::MatchFailed;
            }
            else {
                if constexpr( std::invocable<ArgT> )
                    return matcher.matches(arg()) ? ResultType::Pass : ResultType::MatchFailed;
                else
                    return matcher.matches(arg) ? ResultType::Pass : ResultType::MatchFailed;
            }
        }

        template<typename ArgT, typename MatcherT>
        auto MatchExprRef<ArgT, MatcherT>::expand(ResultType result) -> ExpressionInfo {
            std::string expanded = matcher.describe() + ((result == ResultType::Pass) ? " matched" : " failed to match");
            return ExpressionInfo{ expanded, {}, Operators::None, {} };

        }

    } // namespace Detail

    namespace GenericMatchers {
        template<typename T>
        struct Equals {
            T& match_value;

            [[nodiscard]] constexpr auto matches(std::remove_const_t<T>& value) const -> MatchResult {
                return value == match_value;
            }
            [[nodiscard]] constexpr auto matches(T const& value) const -> MatchResult {
                return value == match_value;
            }
            constexpr auto describe() const {
                return std::format("equals( {} )", stringify(match_value));
            }
        };
    }
    namespace StringMatchers {

        struct CaseSensitive {
            static bool equal(std::string_view str1, std::string_view str2);
            static bool find(std::string_view str, std::string_view substr);
        };
        struct CaseInsensitive {
            static bool equal(std::string_view str1, std::string_view str2);
            static bool find(std::string_view str, std::string_view substr);
        };

        template<typename CasePolicy=CaseSensitive>
        struct StartsWith {
            std::string_view match_str;

            [[nodiscard]] constexpr auto matches(std::string_view str) const -> MatchResult {
                if( match_str.size() > str.size() )
                    return false;
                return CasePolicy::equal(str.substr(0, match_str.size()), match_str);
            }
            constexpr auto describe() const {
                return std::format("starts_with(\"{}\")", match_str);
            }
        };
        template<typename CasePolicy=CaseSensitive>
        struct EndsWith {
            std::string_view match_str;

            [[nodiscard]] constexpr auto matches(std::string_view str) const -> MatchResult {
                if( match_str.size() > str.size() )
                    return false;
                return CasePolicy::equal(str.substr(str.size()-match_str.size()), match_str);
            }
            constexpr auto describe() const {
                return std::format("ends_with(\"{}\")", match_str);
            }
        };
        template<typename CasePolicy=CaseSensitive>
        struct Contains {
            std::string_view match_str;
            [[nodiscard]] constexpr auto matches(std::string_view str) const -> MatchResult {
                return CasePolicy::find(str, match_str);
            }
            constexpr auto describe() const {
                return std::format("contains(\"{}\")", match_str);
            }
        };
        template<typename CasePolicy=CaseSensitive>
        struct Equals {
            std::string_view match_str;

            [[nodiscard]] constexpr auto matches(std::string_view str) const -> MatchResult {
                return CasePolicy::equal(str, match_str);
            }
            constexpr auto describe() const {
                return std::format("equals(\"{}\")", match_str);
            }
        };
    } // namespace StringMatchers

    namespace ExceptionMatchers {
        template<typename E=void>
        struct Throws {
            std::string message; // optional

            template<typename MessageMatcher>
            struct WithMatcher {
                MessageMatcher const& message_matcher;
                [[nodiscard]] constexpr MatchResult matches_lazy(auto f) const {
                    if( auto result = Detail::check_throws<E, true>(f) )
                        return message_matcher.matches(*result);
                    return false;
                }
                constexpr auto describe() const {
                    return std::format("throws().with_message_that( {} )", message_matcher.describe());
                }
            };
            struct WithEqualsMatcher {
                StringMatchers::Equals<> message_matcher;
                [[nodiscard]] constexpr MatchResult matches_lazy(auto f) const {
                    if( auto result = Detail::check_throws<E, true>(f) )
                        return message_matcher.matches(*result);
                    return false;
                }
                constexpr auto describe() const {
                    return std::format("throws().with_message_that( {} )", message_matcher.describe());
                }
            };

            template<Detail::IsEagerMatcher MessageMatcher>
            auto constexpr with_message_that(MessageMatcher const& message_matcher ) {
                return WithMatcher<MessageMatcher> {message_matcher};
            }
            auto constexpr with_message(std::string_view message_to_match) {
                return WithEqualsMatcher {message_to_match};
            }

            [[nodiscard]] constexpr auto matches_lazy(auto f) const -> MatchResult {
                if (message.empty())
                    return Detail::check_throws<E, false>(f).has_value();

                if(auto result = Detail::check_throws<E, true>(f))
                    return *result == message;

                return false;
            }
            constexpr auto describe() const {
                return std::format("throws()"); // !TBD: type and value?
            }
        };

        template<typename E=void>
        struct DoesntThrow {
            [[nodiscard]] constexpr auto matches_lazy(auto f) const -> MatchResult {
                return !Detail::check_throws<E, false>(f).has_value();
            }
            constexpr auto describe() const {
                return std::format("doesnt_throw()"); // !TBD: type and value?
            }
        };

    } // namespace ExceptionMatchers

    namespace FloatMatchers {
        struct IsCloseTo {
            double target;

            [[nodiscard]] constexpr auto matches(double value) const -> MatchResult {
                // !TBD: use better approach
                return std::fabs(value-target) < 10*std::numeric_limits<double>::epsilon();
            }
            constexpr auto describe() const {
                return std::format("is_close_to({})", target);
            }
        };
    } // namespace FloatMatchers

    namespace VectorMatchers {
        template<typename T, typename AllocatorT>
        struct Equals {
            std::vector<T, AllocatorT> const& match_vec;

            [[nodiscard]] constexpr auto matches(auto const& vec) const -> MatchResult {
                if (match_vec.size() != vec.size())
                    return false;
                return std::equal(match_vec.begin(), match_vec.end(), vec.begin());
            }
            constexpr auto describe() const {
                // return std::format("equals({})", match_vec);
                return std::format("equals(vec)"); // !TBD
            }
        };
    }

    namespace Matchers {
        using StringMatchers::CaseSensitive;
        using StringMatchers::CaseInsensitive;

        template<class T>
        concept NotStringViewable = !std::is_convertible_v<T, std::string_view>;

        template<NotStringViewable T>
        constexpr auto equals(T& value) { return GenericMatchers::Equals<T>{value}; }

        template<NotStringViewable T>
        constexpr auto equals(T&& value) { return GenericMatchers::Equals<T>{value}; }

        template<typename CasePolicy=CaseSensitive>
        constexpr auto starts_with(std::string_view str) { return StringMatchers::StartsWith<CasePolicy>{str}; }

        template<typename CasePolicy=CaseSensitive>
        constexpr auto ends_with(std::string_view str) { return StringMatchers::EndsWith<CasePolicy>{str}; }

        template<typename CasePolicy=CaseSensitive>
        constexpr auto contains(std::string_view str) { return StringMatchers::Contains<CasePolicy>{str}; }

        template<typename CasePolicy=CaseSensitive>
        constexpr auto equals(std::string_view str) { return StringMatchers::Equals<CasePolicy>{str}; }

        constexpr auto is_close_to(double target) { return FloatMatchers::IsCloseTo{target}; }

        constexpr auto is_true() { static bool true_value = true; return equals(true_value); }
        constexpr auto is_false() { static bool false_value = false; return equals(false_value); }

        template<typename T, typename AllocatorT>
        constexpr auto equals(std::vector<T, AllocatorT> const& vec) { return VectorMatchers::Equals<T, AllocatorT>{vec}; }

        template<typename T, typename AllocatorT>
        constexpr auto equals(std::vector<T, AllocatorT>& vec) { return VectorMatchers::Equals<T, AllocatorT>{vec}; }

        template<typename E=void>
        using throws = ExceptionMatchers::Throws<E>;

        // !TBD: Get !throws working to avoid needing this
        // - requires the composition matchers (esp Not) handling lazy matchers
        template<typename E=void>
        using doesnt_throw = ExceptionMatchers::DoesntThrow<E>;

        using Detail::operator &&;
        using Detail::operator ||;
        using Detail::operator !;

    } // namespace Matchers

} // namespace CatchKit

// From source files:

// Packed from catchkit/src/assert_result_handler.cpp
namespace CatchKit::Detail {

    void AssertResultHandler::on_assertion_start( ResultDisposition result_disposition, AssertionContext&& context ) {
        current_context = std::move(context);
        this->result_disposition = result_disposition;
    }

    void AssertResultHandler::on_assertion_result( ResultType result, std::optional<ExpressionInfo> const& expression_info, std::string_view message ) {;
        last_result = result;

        // !TBD When we can use stacktrace do something like this:
        // https://godbolt.org/z/jM4TnaMEW

        auto os = stdout;
        if (last_result != ResultType::Pass )
            os = stderr;

        std::println(os, "{}:{}:{}: in function '{}'",
                current_context.location.file_name(),
                current_context.location.line(),
                current_context.location.column(),
                current_context.location.function_name());
        std::string_view macro_name = current_context.macro_name;
        if ( macro_name.empty() )
            macro_name = "assertion";
        if ( !current_context.original_expression.empty() )
            std::println(os, "{} {} for expression:\n\t{}",
                macro_name, (result == ResultType::Pass) ? "passed" : "failed",
                current_context.original_expression);
        else
            std::println(os, "{} {}",
                macro_name, (result == ResultType::Pass) ? "passed" : "failed");
        switch( result ) {
            case ResultType::UnexpectedException:
                std::println(os, "due to an unexpected exception");
                break;
            case ResultType::MissingException:
                std::println(os, "due to a missing exception");
                break;
            default:
                if(expression_info)
                    std::println(os, "with expansion:\n\t{}", *expression_info );
                break;
        }
        if (!message.empty()) {
            std::println(os, "with message:\n\t{}", message);
        }
    }
    void AssertResultHandler::on_assertion_end() {
        if ( last_result != ResultType::Pass && result_disposition == ResultDisposition::Abort ) {
            std::terminate();
        }
    }

} // namespace CatchKit::Detail

// Packed from catchkit/src/assertion_context.cpp
namespace CatchKit::Detail {

    auto AssertionContext::combine_messages( std::string_view additional_message ) -> std::string {
        if(!message.empty()) {
            if(!additional_message.empty())
                return std::string(message) + "\n" + std::string(additional_message);
            return std::string(message);
        }
        if(!additional_message.empty())
            return std::string(additional_message);
        return {};
    }

} // namespace CatchKit::Detail
// Packed from catchkit/src/checker.cpp
namespace {
    CatchKit::Detail::AssertResultHandler default_assertion_handler;
    constinit CatchKit::Detail::ResultHandler* current_assertion_handler = &default_assertion_handler;
}

constinit CatchKit::Checker check(default_assertion_handler, CatchKit::ResultDisposition::Continue);
constinit CatchKit::Checker require(default_assertion_handler, CatchKit::ResultDisposition::Abort);

namespace CatchKit::Detail {

    // !TBD Do we need to return the old one so it can be set back later?
    // This would probably change to being a pointer
    void set_current_assertion_handler( AssertResultHandler& handler ) {
        current_assertion_handler = &handler;
    }

    auto Checker::operator()(std::string_view message, std::source_location assertion_location) -> Asserter {
        return operator()(AssertionContext{{}, {}, message, assertion_location});
    }

    auto Checker::operator()(AssertionContext&& context) -> Asserter {
        result_handler.on_assertion_start(result_disposition, std::move(context));
        return Asserter{*this};
    }

} // namespace CatchKit::Detail

// Packed from catchkit/src/exceptions.cpp
namespace CatchKit::Detail {

    [[nodiscard]] auto get_exception_message( std::exception_ptr const& ex ) -> std::string {
        std::string message;
        try {
            std::rethrow_exception(ex);
        }
        catch(std::exception& e) {
            return e.what();
        }
        catch (std::string& s) {
            return s;
        }
        catch(...) {
            // !TBD: registry for custom exception translations
            return "<unknown exception type>";
        }
    }

} // namespace CatchKit::Detail
// Packed from catchkit/src/expression_info.cpp
std::format_context::iterator std::formatter<CatchKit::Detail::ExpressionInfo>::format(const CatchKit::Detail::ExpressionInfo& expr, std::format_context& ctx) const {
    if( expr.op == CatchKit::Detail::Operators::None )
        return std::format_to(ctx.out(), "{}", expr.lhs);
    else
        return std::format_to(ctx.out(), "{} {} {}", expr.lhs, expr.op_str, expr.rhs);
}

// Packed from catchkit/src/matchers.cpp
namespace CatchKit {

    // !TBD: test the others
    static_assert(Detail::IsMatcher<GenericMatchers::Equals<bool>>);
    // static_assert(Detail::IsEagerMatcher<GenericMatchers::Equals<char[7]>>);

    namespace StringMatchers {

        bool CaseSensitive::equal(std::string_view str1, std::string_view str2) {
            return str1 == str2;
        }
        bool CaseSensitive::find(std::string_view str, std::string_view substr) {
            return str.find(substr) != std::string_view::npos;
        }
        bool CaseInsensitive::equal(std::string_view str1, std::string_view str2) {
            return std::ranges::equal(str1, str2,
                [](char a, char b) {
                    return std::tolower(a) == std::tolower(b);
                });
        }
        bool CaseInsensitive::find(std::string_view str, std::string_view substr) {
            return !std::ranges::search(str, substr,
                [](char a, char b) {
                    return std::tolower(a) == std::tolower(b);
                }).empty();
        }

    } // namespace StringMatchers

} // namespace CatchKit
// Packed from catchkit/src/result_handler.cpp
namespace CatchKit::Detail
{
    ResultHandler::~ResultHandler() = default;

} // namespace CatchKit::Detail
// Packed from catchkit/src/stringify.cpp
namespace CatchKit::Detail {

    auto parse_enum_name_from_function(std::string_view function_name, bool fully_qualified) -> std::string_view {
        if( auto start = function_name.find("candidate = "); start != std::string_view::npos ) {
            start += 12;
            if( auto end = function_name.find_first_of(",;", start); end != std::string_view::npos ) {
                auto qualified_enum_name = function_name.substr(start, end-start);
                if( fully_qualified )
                    return qualified_enum_name;
                auto last_colon = qualified_enum_name.find_last_of(':');
                assert(last_colon !=  std::string_view::npos);
                return qualified_enum_name.substr(last_colon+1);
            }
        }
        return {};
    }
    auto unknown_enum_to_string(size_t enum_value) -> std::string {
        return std::format("<unknown enum value: {}>", enum_value);
    }

    auto pointer_to_string(void const* p) -> std::string {
        return std::format("0x{:0>8}", reinterpret_cast<intptr_t>(p));
    }

} // namespace CatchKit::Detail

#endif // CATCHKIT_PACKED_H_INCLUDED
