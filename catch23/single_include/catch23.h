/*
 * Catch23
 * Single header - Generated: 2025-11-28 19:52:43.151449
 * ----------------------------------------------------------
 * This file has been generated by merging together multiple source files.
 * Please don't edit it directly.
 *
 * Distributed under the MIT license. See text reproduced, below:
 *
 * Copyright 2025 Phil Nash
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
 * associated documentation files (the “Software”), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE
 */
#ifndef CATCH23_PACKED_H_INCLUDED
#define CATCH23_PACKED_H_INCLUDED

// Packed header

// System includes (for headers):
#include <algorithm>
#include <bit>
#include <cassert>
#include <cmath>
#include <exception>
#include <format>
#include <functional>
#include <generator>
#include <memory>
#include <print>
#include <random>
#include <ranges>
#include <set>
#include <source_location>
#include <sstream>
#include <string>
#include <string_view>
#include <type_traits>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <variant>
#include <vector>

// From header files:

// Packed from catchkit/include/catchkit/result_type.h
namespace CatchKit {

    enum class ResultType {
        Failed = 0,
        Passed = 1
    };

    inline bool operator! (ResultType result) {
        return result == ResultType::Failed;
    }

} // namespace CatchKit


// Packed from catchkit/include/catchkit/expression_info.h
namespace CatchKit {

    struct SubExpressionInfo {
        std::string description;
        bool result;
    };


    struct UnaryExpressionInfo {
        std::string value;
    };
    struct BinaryExpressionInfo {
        std::string lhs;
        std::string rhs;

        std::string_view op;
    };
    struct MatchExpressionInfo {
        std::string candidate_value;
        std::string matcher;

        std::vector<SubExpressionInfo> sub_expressions;
    };
    struct ExceptionExpressionInfo {
        std::string exception_message;
        enum class Type { Expected, Unexpected, Missing };
        Type type;
    };
    struct ExpectationExpressionInfo {
        // !TBD
    };

    using ExpressionInfo = std::variant<
        std::monostate,
        UnaryExpressionInfo,
        BinaryExpressionInfo,
        MatchExpressionInfo,
        ExceptionExpressionInfo,
        ExpectationExpressionInfo>;

} // namespace CatchKit

template<>
struct std::formatter<CatchKit::ExpressionInfo> {
    [[nodiscard]] constexpr static auto parse(std::format_parse_context const& ctx) { return ctx.begin(); }
    static std::format_context::iterator format(CatchKit::ExpressionInfo const& expr, std::format_context& ctx);
};


// Packed from catchkit/include/catchkit/report_on.h
namespace CatchKit {

    enum class ReportOn {
        Nothing = 0,
        PassingTests = 1,
        FailingTests = 2,
        AllResults = PassingTests | FailingTests,
    };

    constexpr ReportOn operator&(ReportOn lhs, ReportOn rhs) {
        return static_cast<ReportOn>(
            static_cast<std::underlying_type_t<ReportOn>>(lhs) &
            static_cast<std::underlying_type_t<ReportOn>>(rhs)
        );
    }
    inline bool report_on_passing(ReportOn report_on) {
        return (report_on & ReportOn::PassingTests) == ReportOn::PassingTests;
    }
    inline bool report_on_failing(ReportOn report_on) {
        return (report_on & ReportOn::FailingTests) == ReportOn::FailingTests;
    }

} // namespace CatchKit


// Packed from catchkit/include/catchkit/result_handler.h
namespace CatchKit::Detail
{
    struct AssertionContext;
    struct VariableCaptureRef;

    enum class ResultDisposition { Abort, Continue };
    enum class ResultDetailNeeded { Yes, No };

    struct ResultHandler {
        ReportOn report_on;

        explicit ResultHandler(ReportOn report_on) : report_on(report_on) {}
        virtual ~ResultHandler();

        virtual void on_assertion_start( ResultDisposition result_disposition, AssertionContext const& context ) = 0;
        [[nodiscard]] virtual auto on_assertion_result( ResultType result ) -> ResultDetailNeeded = 0;
        virtual void on_assertion_result_detail( ExpressionInfo const& expression_info, std::string_view message ) = 0;
        virtual void on_assertion_end() = 0;

        virtual void add_variable_capture(VariableCaptureRef*) { /* do nothing by default */ };
        virtual void remove_variable_capture(VariableCaptureRef*) { /* do nothing by default */ };

    };

} // namespace CatchKit::Detail

namespace CatchKit
{
    using Detail::ResultDisposition;
}


// Packed from catchkit/include/catchkit/assertion_context.h
namespace CatchKit::Detail {

    struct AssertionContext {
        std::string_view macro_name;
        std::string_view original_expression;
        std::string_view message  = {};
        std::source_location location = std::source_location::current();
    };

} // namespace CatchKit::Detail

namespace CatchKit {

    using Detail::AssertionContext;

} // namespace CatchKit


// Packed from catchkit/include/catchkit/assert_result_handler.h
namespace CatchKit::Detail {

    struct AssertResultHandler final : ResultHandler {
        AssertionContext current_context;
        ResultType last_result = ResultType::Passed;
        ResultDisposition current_result_disposition = ResultDisposition::Abort;

        AssertResultHandler() : ResultHandler(ReportOn::FailingTests) {}

        void on_assertion_start( ResultDisposition result_disposition, AssertionContext const& context ) override;
        [[nodiscard]] auto on_assertion_result( ResultType result ) -> ResultDetailNeeded override;
        void on_assertion_result_detail( ExpressionInfo const& expression_info, std::string_view message ) override;
        void on_assertion_end() override;
    };

} // namespace CatchKit::Detail


// Packed from catchkit/include/catchkit/captured_variable.h
namespace CatchKit {

    struct CapturedVariable {
        std::string name;
        std::string type;
        std::string value;
    };

} // namespace CatchKit


// Packed from catchkit/include/catchkit/operators.h
namespace CatchKit::Detail {

    enum class Operators {
        None,
        Equals,
        NotEqualTo,
        GreaterThan,
        LessThan,
        GreaterThanOrEqual,
        LessThanOrEqual
    };

} // namespace CatchKit::Detail


// Packed from catchkit/include/catchkit/expr_ref.h
namespace CatchKit::Detail {

    // Holds binary expression
    template<typename LhsT, typename RhsT, Operators Op>
    struct BinaryExprRef {
        LhsT& lhs;
        RhsT& rhs;

        [[nodiscard]] auto evaluate() const -> ResultType;
        [[nodiscard]] auto expand( ResultType result ) const -> ExpressionInfo;

    };

    // Holds a unary expression - ie just evaluates to a single value
    // Also used for the LHS of a binary expression during decomposition
    template<typename T>
    struct UnaryExprRef {
        T& value;

        [[nodiscard]] auto evaluate() const -> ResultType;
        [[nodiscard]] auto expand( ResultType result ) const -> ExpressionInfo;

        template<Operators Op, typename RhsT>
        auto make_binary_expr( RhsT&& rhs ) noexcept { // NOSONAR (ref is used within its lifetime) NOLINT (misc-typo)
            return BinaryExprRef<T, std::remove_reference_t<RhsT>, Op>{ value, rhs };
        }

        template<typename RhsT>
        [[maybe_unused]] friend auto operator == ( UnaryExprRef lhs, RhsT&& rhs ) noexcept {
            static_assert( !(std::is_pointer_v<T> && !std::is_pointer_v<RhsT> && std::is_integral_v<RhsT>),
                "Comparing pointers against integrals (even 0) is not supported. Do you mean to use nullptr?");
            static_assert( requires{ lhs.value == rhs; } );
            return lhs.template make_binary_expr<Operators::Equals>( std::forward<RhsT>( rhs ) );
        }
        template<typename RhsT>
        [[maybe_unused]] friend auto operator != ( UnaryExprRef lhs, RhsT&& rhs ) noexcept {
            static_assert( !(std::is_pointer_v<T> && !std::is_pointer_v<RhsT> && std::is_integral_v<RhsT>),
                "Comparing pointers against integrals (even 0) is not supported. Do you mean to use nullptr?");
            static_assert( requires{ lhs.value != rhs; } );
            return lhs.template make_binary_expr<Operators::NotEqualTo>( std::forward<RhsT>( rhs ) );
        }
        template<typename RhsT>
        [[maybe_unused]] friend auto operator < ( UnaryExprRef lhs, RhsT&& rhs ) noexcept {
            static_assert( requires{ lhs.value < rhs; } );
            return lhs.template make_binary_expr<Operators::LessThan>( std::forward<RhsT>( rhs ) );
        }
        template<typename RhsT>
        [[maybe_unused]] friend auto operator > ( UnaryExprRef lhs, RhsT&& rhs ) noexcept {
            static_assert( requires{ lhs.value > rhs; } );
            return lhs.template make_binary_expr<Operators::GreaterThan>( std::forward<RhsT>( rhs ) );
        }
        template<typename RhsT>
        [[maybe_unused]] friend auto operator <= ( UnaryExprRef lhs, RhsT&& rhs ) noexcept {
            static_assert( requires{ lhs.value <= rhs; } );
            return lhs.template make_binary_expr<Operators::LessThanOrEqual>( std::forward<RhsT>( rhs ) );
        }
        template<typename RhsT>
        [[maybe_unused]] friend auto operator >= ( UnaryExprRef lhs, RhsT&& rhs ) noexcept {
            static_assert( requires{ lhs.value >= rhs; } );
            return lhs.template make_binary_expr<Operators::GreaterThanOrEqual>( std::forward<RhsT>( rhs ) );
        }
    };

} // namespace CatchKit::Detail


// Packed from catchkit/include/catchkit/internal_compilers.h
#if defined(__clang__)
#  define CATCHKIT_COMPILER_CLANG
#elif defined(__GNUC__) && !defined(__ICC) && !defined(__CUDACC__) // GCC
#  define CATCHKIT_COMPILER_GCC
#  define CATCHKIT_GCC_VERSION (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)
#elif define(_MSC_VER)
#  define CATCHKIT_COMPILER_MSVC
#else
#  define CATCHKIT_COMPILER_OTHER
#endif


// Packed from catchkit/include/catchkit/internal_macro_utils.h
#define CATCHKIT_INTERNAL_STRINGIFY_ARGS(...) #__VA_ARGS__

// Generate a unique name, given a root
#define CATCHKIT_INTERNAL_UNIQUE_NAME_CAT2( first, second ) first##second
#define CATCHKIT_INTERNAL_UNIQUE_NAME_CAT( first, second ) CATCHKIT_INTERNAL_UNIQUE_NAME_CAT2( first, second )
#define CATCHKIT_INTERNAL_UNIQUE_NAME( name ) CATCHKIT_INTERNAL_UNIQUE_NAME_CAT( name, __LINE__ )

// Split list of args into head and tail
#define CATCHKIT_VA_MACRO_HEAD(first, ...) first
#define CATCHKIT_VA_MACRO_TAIL(first, ...) __VA_ARGS__


// Packed from catchkit/include/catchkit/internal_warnings.h
#ifdef CATCHKIT_COMPILER_CLANG
#  define CATCHKIT_CLANG_PRAGMA(w) _Pragma(w)
#  define CATCHKIT_CLANG_PRAGMA_NO_TOOLS(w) _Pragma(w) // used for push/ pop - not defined for other compilers
#  define CATCHKIT_GCC_PRAGMA(w)
#  define CATCHKIT_MSVC_PRAGMA(w)

#elifdef CATCHKIT_COMPILER_GCC
#  if CATCHKIT_GCC_VERSION < 150300
#    define CATCHKIT_CLANG_PRAGMA(w)
#  else
#    define CATCHKIT_CLANG_PRAGMA(w) _Pragma(w) // Invoked for clang tools, regardless of compiler
#  endif
#  define CATCHKIT_CLANG_PRAGMA_NO_TOOLS(w)
#  define CATCHKIT_GCC_PRAGMA(w) _Pragma(w)
#  define CATCHKIT_MSVC_PRAGMA(w)

#elifdef CATCHKIT_COMPILER_MSVC
#  define CATCHKIT_CLANG_PRAGMA(w)
#  define CATCHKIT_CLANG_PRAGMA_NO_TOOLS(w)
#  define CATCHKIT_GCC_PRAGMA(w)
#  define CATCHKIT_MSVC_PRAGMA(w) __pragma(w)

#else
#  define CATCHKIT_CLANG_PRAGMA(w)
#  define CATCHKIT_CLANG_PRAGMA_NO_TOOLS(w)
#  define CATCHKIT_GCC_PRAGMA(w)
#  define CATCHKIT_MSVC_PRAGMA(w)
#endif

#define CATCHKIT_CLANG_WARNING_UNSCOPED_DISABLE(w) CATCHKIT_CLANG_PRAGMA_NO_TOOLS( CATCHKIT_INTERNAL_STRINGIFY_ARGS(clang diagnostic ignored w) )
#define CATCHKIT_CLANG_WARNING_DISABLE(w) CATCHKIT_CLANG_PRAGMA( CATCHKIT_INTERNAL_STRINGIFY_ARGS(clang diagnostic ignored w) )
#define CATCHKIT_GCC_WARNING_DISABLE(w) CATCHKIT_GCC_PRAGMA( CATCHKIT_INTERNAL_STRINGIFY_ARGS(GCC diagnostic ignored w) )
#define CATCHKIT_MSVC_WARNING_DISABLE(w) CATCHKIT_MSVC_PRAGMA( warning( disable:w ) )

// Start warning suppression block >>>
#define CATCHKIT_WARNINGS_SUPPRESS_START \
    CATCHKIT_GCC_PRAGMA( "GCC diagnostic push" ) \
    CATCHKIT_GCC_PRAGMA( "GCC diagnostic ignored \"-Wunknown-pragmas\"") \
    CATCHKIT_CLANG_PRAGMA_NO_TOOLS( "clang diagnostic push" ) \
    CATCHKIT_MSVC_PRAGMA ( warning(push) )

// End warning suppression block <<<
#define CATCHKIT_WARNINGS_SUPPRESS_END \
    CATCHKIT_CLANG_PRAGMA_NO_TOOLS( "clang diagnostic pop" ) \
    CATCHKIT_GCC_PRAGMA( "GCC diagnostic pop" ) \
    CATCHKIT_MSVC_PRAGMA( warning(pop) )


#define CATCHKIT_WARNINGS_SUPPRESS_PARENTHESES \
    CATCHKIT_CLANG_WARNING_DISABLE( "-Wparentheses" ) \
    CATCHKIT_GCC_WARNING_DISABLE  ( "-Wparentheses" )

#define CATCHKIT_WARNINGS_SUPPRESS_UNUSED_COMPARISON \
    CATCHKIT_CLANG_WARNING_DISABLE( "-Wunused-comparison" )

#define CATCHKIT_WARNINGS_SUPPRESS_ADDRESS \
    CATCHKIT_CLANG_WARNING_DISABLE( "-Waddress" ) \
    CATCHKIT_GCC_WARNING_DISABLE  ( "-Waddress" )

#define CATCHKIT_WARNINGS_SUPPRESS_SIGN_MISMATCH \
    CATCHKIT_CLANG_WARNING_DISABLE( "-Wsign-compare" ) \
    CATCHKIT_GCC_WARNING_DISABLE  ( "-Wsign-compare" ) \
    CATCHKIT_MSVC_WARNING_DISABLE( 4389 ) /* 'equality-operator' : signed/unsigned mismatch */ \
    CATCHKIT_MSVC_WARNING_DISABLE( 4018 ) /* 'token' : signed/unsigned mismatch */

#define CATCHKIT_WARNINGS_SUPPRESS_UNUSED_PARAMETER \
    CATCHKIT_CLANG_WARNING_DISABLE( "-Wunused-parameter" ) \
    CATCHKIT_GCC_WARNING_DISABLE  ( "-Wunused-parameter" )

#define CATCHKIT_WARNINGS_UNSCOPED_SUPPRESS_UNUSED_PARAMETER \
    CATCHKIT_CLANG_WARNING_UNSCOPED_DISABLE( "-Wunused-parameter" ) \
    CATCHKIT_GCC_WARNING_DISABLE  ( "-Wunused-parameter" )

#define CATCHKIT_WARNINGS_SUPPRESS_FLOAT_RANGE \
    CATCHKIT_CLANG_WARNING_DISABLE( "-Wliteral-range" )

#define CATCHKIT_WARNINGS_SUPPRESS_NULL_CONVERSION \
    CATCHKIT_CLANG_WARNING_DISABLE( "-Wnull-conversion" )

#define CATCHKIT_WARNINGS_SUPPRESS_SHADOW \
    CATCHKIT_CLANG_WARNING_DISABLE( "-Wshadow" ) \
    CATCHKIT_GCC_WARNING_DISABLE  ( "-Wshadow" )

#define CATCHKIT_WARNINGS_UNSCOPED_SUPPRESS_SHADOW \
    CATCHKIT_CLANG_WARNING_UNSCOPED_DISABLE( "-Wshadow" ) \
    CATCHKIT_GCC_WARNING_DISABLE  ( "-Wshadow" )



// Packed from catchkit/include/catchkit/operator_to_string.h
namespace CatchKit::Detail {

    // String conversions for operator enum
    template<Operators op>
    [[nodiscard]] consteval auto operator_to_string() noexcept
    {
        using enum Operators;
        if constexpr( op == Equals )                    return "==";
        else if constexpr( op == NotEqualTo )           return "!=" ;
        else if constexpr( op == GreaterThan )          return ">";
        else if constexpr( op == LessThan )             return "<";
        else if constexpr( op == GreaterThanOrEqual )   return ">=";
        else if constexpr( op == LessThanOrEqual )      return "<=";
        else {
            // Note that while None is a valid enum value, we should never use it on a path that leads here
            static_assert( false, "Unrecognised operator" );
        }
    }

} // namespace CatchKit::Detail


// Packed from catchkit/include/catchkit/exceptions.h
namespace CatchKit::Detail {

    extern const std::string unknown_exception_message;

    [[nodiscard]] auto get_current_exception_message() -> std::string;

    [[nodiscard]] auto get_exception_message( std::exception_ptr const& ex ) -> std::string;
    [[nodiscard]] auto get_exception_message( std::exception const& ex ) -> std::string;
    [[nodiscard]] auto get_exception_message( std::string const& str ) -> std::string;

    [[nodiscard]] inline auto get_exception_message(...) -> std::string { // NOSONAR NOLINT (misc-typo)
        return unknown_exception_message;
    }

} // namespace CatchKit::Detail


// Packed from catchkit/include/catchkit/reflection.h
namespace CatchKit {
    namespace Detail {
        auto parse_templated_name( std::string const& templated_name, std::source_location location = std::source_location::current() ) -> std::string_view;
        template<typename T>
        auto type_to_string() -> std::string_view {
            // Handle common built-in types directly to save instantiating a std::source_location
            if constexpr( std::is_same_v<T, int> )
                return "int";
            if constexpr( std::is_same_v<T, bool> )
                return "bool";
            if constexpr( std::is_same_v<T, float> )
                return "float";
            if constexpr( std::is_same_v<T, double> )
                return "double";
            if constexpr( std::is_same_v<T, std::string> )
                return "std::string";
            if constexpr( std::is_same_v<T, std::string_view> )
                return "std::string_view";
            else
                return parse_templated_name("T");
        }

        auto parse_enum_name_from_function(std::string_view function_name, bool fully_qualified = false) -> std::string_view;
        auto unknown_enum_to_string(size_t enum_value) -> std::string;

        constexpr std::size_t enum_probe_start = 0;
        constexpr std::size_t enum_probe_end = 16;

        template<typename E, E candidate=static_cast<E>(enum_probe_start), size_t max_probe=enum_probe_end>
        struct enum_value_string {
            static constexpr auto find(E e) -> std::string_view {
                if( e == candidate )
                    return parse_enum_name_from_function(std::source_location::current().function_name());
                if constexpr(constexpr auto raw_value = static_cast<std::size_t>( candidate );
                    raw_value < max_probe &&
                    requires { std::integral_constant<E, static_cast<E>(raw_value+1)>{}; } ) {
                        return enum_value_string<E, static_cast<E>(raw_value + 1)>::find(e);
                }
                return {};
            }
        };

        template<typename E>
        auto constexpr enum_to_string(E e) -> std::string {
            if( auto val = enum_value_string<E>::find(e); !val.empty() )
                return std::string(val);
            return unknown_enum_to_string(static_cast<size_t>(e));
        }
        auto normalise_type_name(std::string_view type_name) -> std::string;

    } // namespace Detail

    using Detail::type_to_string;
    using Detail::enum_to_string;

} // namespace CatchKit


// Packed from catchkit/include/catchkit/stringify.h
#ifdef CATCHKIT_FALLBACK_TO_OSTREAM_STRING_CONVERSIONS
#include <sstream>
#endif

namespace CatchKit {

    auto pointer_to_string(std::uintptr_t p) -> std::string;

    inline auto pointer_to_string(void const* p) -> std::string {
        return pointer_to_string(std::bit_cast<std::uintptr_t>(p));
    }

    auto function_pointer_to_string(auto p) -> std::string {
        return pointer_to_string(std::bit_cast<std::uintptr_t>(p));
    }
    auto member_pointer_to_string(void const* p, std::size_t size) -> std::string;

    template<typename T>
    auto member_pointer_to_string(T mp) -> std::string {
        return member_pointer_to_string(&mp, sizeof(T));
    }

    // Specialise this with a stringify member function for your own conversions
    template<typename T>
    struct Stringifier;

    template<typename T>
    concept Stringifiable = requires { Stringifier<T>::stringify; };

    template<typename T>
    [[nodiscard]] auto constexpr stringify(T const& value );
}

// This allows any type for which there is a Stringifier specialisation to be usable by std::format.
// This is necessary so that ranges/ containers of custom types will work.
// Note that if you provide both a std::formatter _and_ a Stringifier for your types,
// then stringified _containers_ (or ranges) of them will prefer the std::formatter specialisations.
template<CatchKit::Stringifiable T>
struct std::formatter<T> { // NOLINT
    constexpr static auto parse( std::format_parse_context const& ctx ) { return ctx.begin(); }
    auto format(T const& val, auto& ctx) const {
        return std::format_to( ctx.out(), "{}", CatchKit::Stringifier<T>::stringify(val) );
    }
};

namespace CatchKit {
#ifdef FALLBACK_TO_OSTREAM_STRING_CONVERSIONS
    template <typename T>
    concept Streamable = requires( std::ostream os, T value ) {
        { os << value };
    };
#endif

    // Don't specialise this, specialise Stringifier instead
    template<typename T>
    [[nodiscard]] auto constexpr stringify(T const& value ) {
        if constexpr( std::is_enum_v<T> )
            return enum_to_string( value );
        else if constexpr( std::is_null_pointer_v<T> )
            return std::string("nullptr");
        else if constexpr( std::is_pointer_v<T> ) {
            if( !value )
                return std::string("nullptr");
            if constexpr( std::is_convertible_v<T, char const*> )
                return std::format("\"{}\"", value);
            else if constexpr (std::is_function_v<std::remove_pointer_t<T>>)
                return function_pointer_to_string(value);
            else
                return pointer_to_string( value );
        }
        else if constexpr( std::is_convertible_v<T, std::string> )
            return std::format("\"{}\"", value);
        else if constexpr( std::formattable<T, char> )
            return std::format("{}", value);
#ifdef FALLBACK_TO_OSTREAM_STRING_CONVERSIONS
        else if constexpr ( Streamable<T> ) {
            std::ostringstream oss;
            oss << value;
            return oss.str();
        }
#endif
        else if constexpr (std::is_function_v<T>)
            return function_pointer_to_string( &value );
        else if constexpr( std::is_member_pointer_v<T> )
            return member_pointer_to_string( value );
        else
            return std::format( "{}(?)", type_to_string<T>() );
    }

} // namespace CatchKit


// Packed from catchkit/include/catchkit/variable_capture_ref.h
namespace CatchKit::Detail
{
    struct Checker;
    struct ResultHandler;

    struct VariableCaptureRef {
        std::string_view name;
        std::string_view type;
        ResultHandler& result_handler;

        [[nodiscard]] virtual auto get_value() const -> std::string = 0;

    protected:
        VariableCaptureRef(std::string_view name, std::string_view type, Checker& checker);
        ~VariableCaptureRef(); // not virtual because we never destroy polymorphically
    };

    template<typename T>
    struct TypedVariableCaptureRef final : VariableCaptureRef {
        T const& value;

        [[nodiscard]] auto get_value() const -> std::string override { return stringify( value ); }

        TypedVariableCaptureRef(T const& value, std::string_view name, Checker& checker)
        :   VariableCaptureRef( name, type_to_string<T>(), checker ),
            value(value)
        {}
    };

} // namespace CatchKit::Detail


// Packed from catchkit/include/catchkit/macros.h
#define CATCHKIT_INTERNAL_ASSERT(macro_name, checker_fun, invert_result, ...) \
    checker.checker_fun( CatchKit::AssertionContext(macro_name, #__VA_ARGS__), invert_result ) \
        .handle_unexpected_exceptions([&](CatchKit::Detail::Asserter& asserter){ \
            if( checker.should_decompose ) { \
                CATCHKIT_WARNINGS_SUPPRESS_START \
                CATCHKIT_WARNINGS_SUPPRESS_UNUSED_COMPARISON \
                asserter.accept_expr( asserter <=> __VA_ARGS__ ); \
                CATCHKIT_WARNINGS_SUPPRESS_END \
            } else { \
                asserter.simple_assert(__VA_ARGS__); \
            } \
        })

#define CATCHKIT_INTERNAL_ASSERT_THAT(macro_name, checker_fun, arg, match_expr) \
    checker.checker_fun( CatchKit::AssertionContext(macro_name, #arg ", " #match_expr) ) \
        .handle_unexpected_exceptions([&](CatchKit::Detail::Asserter& asserter){ \
            using namespace CatchKit::Matchers; \
            asserter.assert_that( [&]{ return arg; }, match_expr ); \
        })

#define CATCHKIT_INTERNAL_BOOL_ASSERT(macro_name, checker_fun, pass) \
    checker.checker_fun( CatchKit::AssertionContext(macro_name, {} ) ) \
        .handle_unexpected_exceptions([&](CatchKit::Detail::Asserter& asserter){ \
            asserter.simple_assert( pass ); \
        })

#define CHECK(...) CATCHKIT_INTERNAL_ASSERT( "CHECK", check, CatchKit::Detail::InvertResult::No, __VA_ARGS__ )
#define REQUIRE(...) CATCHKIT_INTERNAL_ASSERT( "REQUIRE", require, CatchKit::Detail::InvertResult::No, __VA_ARGS__ )

#define CHECK_THAT( arg, matcher ) CATCHKIT_INTERNAL_ASSERT_THAT( "CHECK_THAT", check, arg, matcher )
#define REQUIRE_THAT( arg, matcher ) CATCHKIT_INTERNAL_ASSERT_THAT( "REQUIRE_THAT", require, arg, matcher )

// Variable capture
#define CATCHKIT_INTERNAL_DECLARE_VAR_X(suffix, var) CatchKit::Detail::TypedVariableCaptureRef CATCHKIT_INTERNAL_UNIQUE_NAME(var_capture##suffix)(var, #var, checker)

#define CATCHKIT_INTERNAL_DECLARE_VARS_1(a) CATCHKIT_INTERNAL_DECLARE_VAR_X(_1, a)
#define CATCHKIT_INTERNAL_DECLARE_VARS_2(a, b) CATCHKIT_INTERNAL_DECLARE_VAR_X(_1, a); CATCHKIT_INTERNAL_DECLARE_VAR_X(_2, b)
#define CATCHKIT_INTERNAL_DECLARE_VARS_3(a, b, c) CATCHKIT_INTERNAL_DECLARE_VAR_X(_1, a); CATCHKIT_INTERNAL_DECLARE_VAR_X(_2, b); CATCHKIT_INTERNAL_DECLARE_VAR_X(_3, c)
#define CATCHKIT_INTERNAL_DECLARE_VARS_4(a, b, c, d) CATCHKIT_INTERNAL_DECLARE_VAR_X(_1, a); CATCHKIT_INTERNAL_DECLARE_VAR_X(_2, b); CATCHKIT_INTERNAL_DECLARE_VAR_X(_3, c); CATCHKIT_INTERNAL_DECLARE_VAR_X(_4, d)

#define CATCHKIT_INTERNAL_DECLARE_VARS_ERROR(...) \
    static_assert(false, \
        "CAPTURE ERROR: Too many variable names provided! " \
        "This macro supports a maximum of 4 variables. " \
        "Consider breaking into multiple CAPTURE calls.")

#define CATCHKIT_INTERNAL_GET_6TH_ARG(arg1, arg2, arg3, arg4, arg5, arg6, ...) arg6
#define CATCHKIT_INTERNAL_DECLARE_VARS_CHOOSER(...) CATCHKIT_INTERNAL_GET_6TH_ARG(__VA_ARGS__, CATCHKIT_INTERNAL_DECLARE_VARS_ERROR, CATCHKIT_INTERNAL_DECLARE_VARS_4, CATCHKIT_INTERNAL_DECLARE_VARS_3, CATCHKIT_INTERNAL_DECLARE_VARS_2, CATCHKIT_INTERNAL_DECLARE_VARS_1)

#define CATCHKIT_INTERNAL_VAR(...) CATCHKIT_INTERNAL_DECLARE_VARS_CHOOSER(__VA_ARGS__)(__VA_ARGS__)
#define CAPTURE(...) CATCHKIT_INTERNAL_VAR(__VA_ARGS__)

// Static assert
#define REQUIRE_STATIC(...) static_assert(__VA_ARGS__)

#define PASS() CATCHKIT_INTERNAL_BOOL_ASSERT( "PASS", check, true )
#define FAIL() CATCHKIT_INTERNAL_BOOL_ASSERT( "FAIL", require, false )


// Packed from catchkit/include/catchkit/checker.h
namespace CatchKit::Detail
{
    class Asserter;
    struct MatchResult;

    enum class InvertResult { No = 0, Yes = 1 };

    struct Checker {
        ResultHandler* result_handler = nullptr;
        bool should_decompose = true;
        std::optional<std::ostringstream> message_stream = {};

        auto check(AssertionContext const& context, InvertResult invert_result=InvertResult::No) -> Asserter;
        auto require(AssertionContext const& context, InvertResult invert_result=InvertResult::No) -> Asserter;
    };

    inline auto to_result_type( ResultType result ) -> ResultType { return result; }
    auto to_result_type( MatchResult const& result ) -> ResultType; // Implemented in internal_matchers.h

    class Asserter {
        Checker& checker;
        InvertResult invert_result = InvertResult::No;

        std::optional<ExpressionInfo> expression_info;

        void report_current_exception() const;
    public:
        explicit Asserter( Checker& checker, InvertResult invert_result );
        ~Asserter() noexcept(false); // NOSONAR NOLINT (misc-typo)

        auto& handle_unexpected_exceptions(std::invocable<Asserter&> auto const& expr_call) {
            try {
                expr_call(*this);
            }
            catch(...) {
                report_current_exception();
            }
            return *this;
        }

        void simple_assert(std::nullptr_t) noexcept {
            simple_assert(false);
        }
        void simple_assert(auto const& result) noexcept {
            if( checker.result_handler->on_assertion_result(!result ? ResultType::Failed : ResultType::Passed) == ResultDetailNeeded::Yes ) {
                expression_info = std::monostate();
            }
        }
        void accept_expr(auto&& expr) noexcept {  // NOSONAR NOLINT (misc-typo)
            auto raw_result = expr.evaluate();
            auto result = to_result_type( raw_result );
            if( invert_result == InvertResult::Yes )
                result = result == ResultType::Failed ? ResultType::Passed : ResultType::Failed;
            if( checker.result_handler->on_assertion_result( result ) == ResultDetailNeeded::Yes ) {
                expression_info = expr.expand( raw_result );
            }
        }

        template<typename ArgT, typename MatcherT>
        constexpr void assert_that( ArgT&& arg, MatcherT&& matcher ) noexcept;

        [[maybe_unused]] friend auto& operator << ( Asserter& asserter, auto&& message ) {
            if( asserter.expression_info ) {
                if( !asserter.checker.message_stream )
                    asserter.checker.message_stream.emplace();
                *asserter.checker.message_stream << message;
            }
            return asserter;
        }

        // To kick off an expression decomposition
        [[maybe_unused]] friend constexpr auto operator <=> ( Asserter const&, auto&& value ) noexcept { // NOSONAR NOLINT (misc-typo)
            return UnaryExprRef{ value };
        }
    };

    // --------------

    template<typename T>
    auto UnaryExprRef<T>::evaluate() const -> ResultType {
        using enum ResultType;
        if constexpr( requires (T v){ { !v } -> std::same_as<bool>; }) {
            CATCHKIT_WARNINGS_SUPPRESS_START
            CATCHKIT_WARNINGS_SUPPRESS_ADDRESS
            CATCHKIT_WARNINGS_SUPPRESS_NULL_CONVERSION
            return !value ? Failed : Passed;
            CATCHKIT_WARNINGS_SUPPRESS_END
        }
        else {
            // Special case for GCC
            static_assert( std::is_null_pointer_v<T> );
            return Failed;
        }
    }
    template<typename T>
    auto UnaryExprRef<T>::expand(ResultType) const -> ExpressionInfo {
        return UnaryExpressionInfo{ stringify(value) };
    }

    CATCHKIT_WARNINGS_SUPPRESS_START
    CATCHKIT_WARNINGS_SUPPRESS_SIGN_MISMATCH
    template<typename LhsT, typename RhsT, Operators Op>
    auto eval_expr(BinaryExprRef<LhsT, RhsT, Op> const& expr) {
        using enum Operators;
        if constexpr( Op == Equals )                    return expr.lhs == expr.rhs;
        else if constexpr( Op == NotEqualTo )           return expr.lhs != expr.rhs;
        else if constexpr( Op == GreaterThan )          return expr.lhs >  expr.rhs;
        else if constexpr( Op == LessThan )             return expr.lhs <  expr.rhs;
        else if constexpr( Op == GreaterThanOrEqual )   return expr.lhs >= expr.rhs;
        else if constexpr( Op == LessThanOrEqual )      return expr.lhs <= expr.rhs;
        else {
            // Note that while None is a valid enum value, we should never use it on a path that leads here
            static_assert( false, "Operator not implemented" );
        }
        std::unreachable();
    }
    CATCHKIT_WARNINGS_SUPPRESS_END

    template<typename LhsT, typename RhsT, Operators Op>
    auto BinaryExprRef<LhsT, RhsT, Op>::evaluate() const -> ResultType {
        return static_cast<bool>( eval_expr(*this) ) ? ResultType::Passed : ResultType::Failed;
    }
    template<typename LhsT, typename RhsT, Operators Op>
    auto BinaryExprRef<LhsT, RhsT, Op>::expand(ResultType) const -> ExpressionInfo {
        return BinaryExpressionInfo{
            std::string( stringify(lhs) ),
            std::string( stringify(rhs) ),
            operator_to_string<Op>() };
    }

} // namespace CatchKit::Detail

namespace CatchKit
{
    using Detail::Checker;

} // namespace CatchKit

// This global instance is used if not using the one passed in to a function locally
extern constinit CatchKit::Checker checker; // NOSONAR NOLINT (misc-typo)


// Packed from catchkit/include/catchkit/internal_matchers.h
namespace CatchKit {

    namespace Detail {

        struct SubExpression {
            bool result;
            uintptr_t matcher_address;
        };

        // Holds the result of a match
        struct MatchResult {
            bool result;
            uintptr_t matcher_address;

            explicit(false) MatchResult( bool result, uintptr_t matcher_address = 0 ) : result(result), matcher_address(matcher_address) {}
            explicit operator bool() const { return result; }

            template<typename T, typename Self>
            auto&& set_address_of(this Self&& self, T const& object) {
                self.set_address( std::bit_cast<uintptr_t>( &object ) );
                return std::forward<Self>(self);
            }

        private:
            void set_address( uintptr_t address );
        };

        // A match result for composite matchers (with &&, ||, ! and >>)
        struct CompositeMatchResult : MatchResult { // NOSONAR NOLINT (misc-typo)
            std::vector<SubExpression> child_results;

            using MatchResult::MatchResult;
            explicit(false) CompositeMatchResult( MatchResult const& other ) : MatchResult( other ) {}
            CompositeMatchResult( CompositeMatchResult&& other ) = default;

            auto add_children_from( MatchResult const& ) -> CompositeMatchResult&& { return std::move(*this); }
            auto add_children_from( CompositeMatchResult const& other) -> CompositeMatchResult&&;
            auto make_child_of( uintptr_t address ) -> CompositeMatchResult&&;
            auto make_child_of( auto const& matcher ) -> CompositeMatchResult&& { return make_child_of( std::bit_cast<uintptr_t>( matcher ) ); }
        };

        struct MatcherDescription {
            std::string description;

            template<typename T> requires std::is_convertible_v<T, std::string>
            explicit(false) MatcherDescription( T&& description) // NOSONAR NOLINT (misc-typo)
            : description(std::forward<T>( description )) {}
        };

        inline auto to_result_type( MatchResult const& result ) -> ResultType { return result ? ResultType::Passed : ResultType::Failed; }

        struct AlwaysMatcher {
            static auto match(auto&&) -> MatchResult { return true; }
            static auto lazy_match(auto&&) -> MatchResult  { return true; }
        };

        template<typename M>
        concept IsMatcher = requires(M m) {
            { m.describe() } -> std::same_as<MatcherDescription>;
        };

        template<typename M, typename T>
        concept IsEagerMatcher = requires(M m, T arg) {
            { m.match(arg) } -> std::convertible_to<MatchResult>;
        };

        template<typename M, typename T>
        concept IsLazyMatcher = requires(M m, T(*f)()) {
            { m.lazy_match(f) } -> std::convertible_to<MatchResult>;
        };

        template<typename M, typename T>
        concept IsEagerBindableMatcher = requires(M m, T arg, AlwaysMatcher matcher) {
            { m.match(arg, matcher) } -> std::convertible_to<MatchResult>;
        };

        template<typename M, typename T>
        concept IsLazyBindableMatcher = requires(M m, T(*f)(), AlwaysMatcher matcher) {
            { m.lazy_match(f, matcher) } -> std::convertible_to<MatchResult>;
        };

        template<typename M>
        concept IsCompositeMatcher = requires {
            typename std::remove_cvref_t<M>::ComposedMatcher1;
        };

        template<typename M>
        concept IsBinaryCompositeMatcher = requires {
            typename M::ComposedMatcher1;
            typename M::ComposedMatcher2;
        };

        template<typename M>
        concept IsUnaryCompositeMatcher = IsCompositeMatcher<M> && !IsBinaryCompositeMatcher<M>;

        template<typename MatcherT>
        constexpr void enforce_composite_matchers_are_rvalues() {
            static_assert(!IsCompositeMatcher<MatcherT> || !std::is_lvalue_reference_v<MatcherT>,
                "Composite Matchers (&&, ||, !) cannot be stored in variables. Use them inline");
        }


        template<typename ArgT, typename MatcherT>
        auto invoke_matcher( MatcherT& matcher, ArgT&& arg ) {
            if constexpr( std::invocable<ArgT> ) {
                using ReturnedArgType = decltype(arg());
                if constexpr( IsLazyMatcher<MatcherT, ReturnedArgType> ) {
                    return matcher.lazy_match( arg ).set_address_of( matcher );
                }
                else {
                    static_assert( IsEagerMatcher<MatcherT, ReturnedArgType> );
                    return matcher.match( arg() ).set_address_of( matcher );
                }
            }
            else {
                static_assert( IsEagerMatcher<MatcherT, ArgT> );
                return matcher.match( arg ).set_address_of( matcher );
            }
        }


        // The result of a && expression
        template<typename M1, typename M2>
        struct AndMatcher {
            using ComposedMatcher1 = M1;
            using ComposedMatcher2 = M2;
            M1& matcher1;
            M2& matcher2;

            auto match( auto const& value ) const -> CompositeMatchResult {
                auto result1 = CompositeMatchResult( invoke_matcher( matcher1, value ) ).make_child_of(this);
                if( !result1 )
                    return result1; // Short circuit
                return CompositeMatchResult(invoke_matcher( matcher2, value ))
                    .make_child_of(this) // Create new matcher for this level
                    .add_children_from(result1); // add in the other result

            }
            [[nodiscard]] auto describe() const -> MatcherDescription {
                return std::format("({} && {})", matcher1.describe().description, matcher2.describe().description);
            }
        };

        // The result of a || expression
        template<typename M1, typename M2>
        struct OrMatcher {
            using ComposedMatcher1 = M1;
            using ComposedMatcher2 = M2;
            M1& matcher1;
            M2& matcher2;

            auto match( auto const& value ) const -> CompositeMatchResult {
                auto result1 = CompositeMatchResult( invoke_matcher(matcher1, value) )
                    .make_child_of(this);
                if( result1 )
                    return result1; // Short circuit
                return CompositeMatchResult( invoke_matcher( matcher2,  value ) )
                    .make_child_of(this) // Create new matcher for this level
                    .add_children_from(result1); // add in the other result
            }
            [[nodiscard]] auto describe() const -> MatcherDescription {
                return std::format("({} || {})", matcher1.describe().description, matcher2.describe().description);
            }
        };

        // The result of a ! expression
        template<typename M>
        struct NotMatcher {
            using ComposedMatcher1 = M;
            M& base_matcher;

            auto match( auto const& value ) const -> CompositeMatchResult {
                return match_common( value );
            }
            auto lazy_match( auto const& value ) const -> CompositeMatchResult {
                return match_common( value );
            }
            auto match_common( auto const& value ) const -> CompositeMatchResult {
                auto result = CompositeMatchResult( invoke_matcher( base_matcher, value ) )
                    .make_child_of(this);
                result.result = !result.result;
                return result;

            }
            [[nodiscard]] auto describe() const -> MatcherDescription {
                return std::format("!({})", base_matcher.describe().description);
            }
        };

        template<IsMatcher M1, typename M2>
        auto operator && ( M1&& m1, M2&& m2 ) { // NOSONAR NOLINT (misc-typo)
            enforce_composite_matchers_are_rvalues<M1>();
            enforce_composite_matchers_are_rvalues<M2>();
            static_assert(IsMatcher<M2>, "Operand to && is not a matcher");
            return AndMatcher(m1, m2);
        }

        template<IsMatcher M1, typename M2>
        auto operator || ( M1&& m1, M2&& m2 ) { // NOSONAR NOLINT (misc-typo)
            enforce_composite_matchers_are_rvalues<M1>();
            enforce_composite_matchers_are_rvalues<M2>();
            static_assert(IsMatcher<M2>, "Operand to || is not a matcher");
            return OrMatcher( m1, m2 );
        }

        template<IsMatcher MatcherT>
        auto operator ! (MatcherT&& m) { // NOSONAR NOLINT (misc-typo)
            enforce_composite_matchers_are_rvalues<MatcherT>();
            return NotMatcher(m);
        }

        // Matchers may be monadically bound with the >>= operator.
        // If so, the left operand must implement match(arg, bound_matcher)
        template<typename M1, typename M2>
        struct BoundMatchers {
            using ComposedMatcher1 = M1;
            using ComposedMatcher2 = M2;
            M1 matcher1;
            M2 matcher2;

            template<typename ArgT>
            auto lazy_match( ArgT const& arg ) const -> CompositeMatchResult {
                if constexpr ( IsLazyBindableMatcher<M1, ArgT> ) {
                    static_assert( std::invocable<ArgT>, "Lazy matchers must be matched against lambdas" );
                    return matcher1.lazy_match(arg, matcher2)
                        .set_address_of( matcher1 )
                        .make_child_of(this);
                }
                else
                    return match(arg);
            }

            template<typename ArgT>
            auto match( ArgT const& arg ) const -> CompositeMatchResult {
                static_assert( IsEagerBindableMatcher<M1, ArgT>, "The LHS of >>= must be a bindable matcher" );
                if constexpr( std::invocable<ArgT> )
                    return CompositeMatchResult( matcher1.match(arg(), matcher2) )
                        .set_address_of( matcher1 )
                        .make_child_of(this);
                else
                    return CompositeMatchResult( matcher1.match(arg, matcher2) )
                        .set_address_of( matcher1 )
                        .make_child_of(this);
            }

            [[nodiscard]] auto describe() const -> MatcherDescription {
                return std::format("({} >>= {})", matcher1.describe().description, matcher2.describe().description);
            }
        };

        template<IsMatcher M1, typename M2>
        auto operator >>= ( M1&& m1, M2&& m2 ) {
            static_assert(IsMatcher<M2>, "Operand to >>= is not a matcher");
            return BoundMatchers{std::forward<M1>(m1), std::forward<M2>(m2)};
        }

        void add_subexpressions( std::vector<SubExpressionInfo>& sub_expressions, CompositeMatchResult const& results, uintptr_t matcher_address, std::string const& description );

        template<typename M>
        auto collect_subexpressions(M const& matcher, std::vector<SubExpressionInfo>& sub_expressions, CompositeMatchResult const& results) {
            if constexpr( IsBinaryCompositeMatcher<M> ) {
                collect_subexpressions(matcher.matcher1, sub_expressions, results);
                collect_subexpressions(matcher.matcher2, sub_expressions, results);
            }
            else if constexpr( IsUnaryCompositeMatcher<M> ) {
                collect_subexpressions(matcher.base_matcher, sub_expressions, results);
            }
            else {
                add_subexpressions( sub_expressions, results, std::bit_cast<uintptr_t>(&matcher), matcher.describe().description );
            }
        }

        template<typename ArgT, typename MatcherT>
        struct MatchExprRef {
            ArgT& arg;
            MatcherT const& matcher;

            [[nodiscard]] auto evaluate() const {
                return invoke_matcher( matcher, arg );
            }
            [[nodiscard]] auto arg_as_string() const -> std::string {
                try {
                    if constexpr ( !std::invocable<ArgT> )
                        return stringify(arg);
                    else if constexpr (!std::is_void_v<decltype(arg())>)
                        return stringify(arg());
                    else
                        return {};
                }
                catch(...) {
                    return std::format("exception thrown while evaluating matcher: {}", get_current_exception_message() );
                }
            }
            [[nodiscard]] auto expand( MatchResult const& ) const -> ExpressionInfo {
                return MatchExpressionInfo{ arg_as_string(), matcher.describe().description, {} };
            }
            [[nodiscard]] auto expand( CompositeMatchResult const& result ) const -> ExpressionInfo {
                std::vector<SubExpressionInfo> sub_expressions;
                if constexpr ( IsCompositeMatcher<MatcherT>) {
                    collect_subexpressions(matcher, sub_expressions, result);
                }
                return MatchExpressionInfo{ arg_as_string(), matcher.describe().description, std::move(sub_expressions) };
            }
        };


        template<typename ArgT, typename MatcherT>
        constexpr void Asserter::assert_that( ArgT&& arg, MatcherT&& matcher ) noexcept { // NOSONAR (we use the ref in its lifetime) NOLINT (misc-typo)
            enforce_composite_matchers_are_rvalues<MatcherT>();
            accept_expr( MatchExprRef{ arg, matcher } );
        }

    } // namespace Detail

    namespace Matchers {

        using Detail::operator &&;
        using Detail::operator ||;
        using Detail::operator !;
        using Detail::operator >>=;

    } // namespace Matchers

    using Detail::MatchResult;
    using Detail::CompositeMatchResult;
    using Detail::MatcherDescription;

} // namespace CatchKit


// Packed from catchkit/include/catchkit/internal_platform.h
#if defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER) || defined(__MINGW32__)
#  define CATCHKIT_PLATFORM_WINDOWS
#else
#  define CATCHKIT_PLATFORM_POSIX
#  if defined(linux) || defined(__linux) || defined(__linux__)
#    define CATCHKIT_PLATFORM_LINUX
#  elifdef __APPLE__
#    define CATCHKIT_PLATFORM_APPLE
#    include <TargetConditionals.h>
#    if TARGET_OS_OSX == 1
#      define CATCHKIT_PLATFORM_MAC
#    elif TARGET_OS_IPHONE == 1
#      define CATCHKIT_PLATFORM_IPHONE
#    endif
#  elif defined(linux) || defined(__linux) || defined(__linux__)
#    define CATCHKIT_PLATFORM_LINUX
#  endif
#endif


// Packed from catchkit/include/catchkit/matchers.h
namespace CatchKit {

    template<class T>
    concept IsStringViewable = std::is_convertible_v<T, std::string_view>;

    template<class T>
    concept NotStringViewable = !std::is_convertible_v<T, std::string_view>;

    template<class T>
    concept NonStringRange = NotStringViewable<T> && std::ranges::sized_range<T>;

    template<class T>
    concept NotARange = NotStringViewable<T> && !std::ranges::sized_range<T>;


    namespace GenericMatchers {
        template<typename T>
        struct Equals {
            T& match_value;

            [[nodiscard]] constexpr auto match(std::remove_const_t<T>& value) const -> MatchResult {
                return value == match_value;
            }
            [[nodiscard]] constexpr auto match(T const& value) const -> MatchResult {
                return value == match_value;
            }
            [[nodiscard]] auto describe() const -> MatcherDescription {
                return std::format("equals( {} )", stringify(match_value));
            }
        };

        struct HasSize {
            std::size_t size;

            [[nodiscard]] auto match(auto&& val) const -> MatchResult { // NOSONAR NOLINT(misc-type)
                return std::size(val) == size;
            }
            [[nodiscard]] auto describe() const -> MatcherDescription {
                return std::format("has_size(\"{}\")", size);
            }
        };

        template<typename PredicateT>
        struct MatchesPredicate {
            PredicateT pred;
            std::string description;

            explicit MatchesPredicate( PredicateT&& pred, std::string description )
            : pred( std::move(pred) ), description( std::move(description) ) {}

            [[nodiscard]] auto match( auto const& arg ) const -> MatchResult {
                return pred(arg);
            }
            [[nodiscard]] auto describe() const -> MatcherDescription {
                return description;
            }
        };
    }

    namespace RangeMatchers {

        struct InOrder {
            static auto equals(auto const& range1, auto const& range2 ) {
                if( std::size(range1) != std::size(range2) )
                    return false;
                for( const auto& [e1, e2] : std::views::zip(range1, range2) )
                    if( e1 != e2 )
                        return false;
                return true;
            }
        };
        struct InAnyOrder {
            static auto equals(auto const& range1, auto const& range2 ) {
                auto set = range2 | std::ranges::to<std::unordered_set>();
                for( const auto& match_element : range1 )
                    if( set.erase(match_element) == 0 )
                        return false;
                return set.empty();
            }
        };

        template<typename T>
        struct ContainsElement {
            T const& element;

            template<typename Range>
            [[nodiscard]] auto match(Range const& range) const -> MatchResult {
                static_assert(std::ranges::sized_range<Range>);
                for( const auto& match_element : range ) {
                    if( element == match_element )
                        return true;
                }
                return false;
            }
            [[nodiscard]] auto describe() const -> MatcherDescription {
                return std::format("contains({})", stringify(element));
            }
        };

        template<typename R>
        struct ContainsRange {
            R const& range;

            template<typename Range>
            [[nodiscard]] auto match(Range const& match_range) const -> MatchResult {
                static_assert(std::ranges::sized_range<Range>);
                auto set = range | std::ranges::to<std::unordered_set>();
                for( const auto& match_element : match_range )
                    set.erase(match_element);
                return set.empty();
            }
            [[nodiscard]] auto describe() const -> MatcherDescription {
                return std::format("contains({})", stringify(range));
            }
        };

        template<typename OrderPolicy, typename R>
        struct Equals {
            R const& range;

            template<typename Range>
            [[nodiscard]] auto match(Range const& match_range) const -> MatchResult {
                static_assert(std::ranges::sized_range<Range>);
                return OrderPolicy::equals(range, match_range);
            }

            [[nodiscard]] auto describe() const -> MatcherDescription {
                return std::format("equals({})", stringify(range));
            }
        };
    }


    namespace StringMatchers {

        struct CaseSensitive {
            static constexpr std::string name = "CaseSensitive";
            static bool equal(std::string_view str1, std::string_view str2);
            static bool find(std::string_view str, std::string_view substr);
            static bool matches_regex(std::string const& str, std::string const& regex_str);
        };
        struct CaseInsensitive {
            static constexpr std::string name = "CaseInsensitive";
            static bool equal(std::string_view str1, std::string_view str2);
            static bool find(std::string_view str, std::string_view substr);
            static bool matches_regex(std::string const& str, std::string const& regex_str);
        };

        template<typename CasePolicy=CaseSensitive>
        struct StartsWith {
            std::string_view match_str;

            [[nodiscard]] auto match(std::string_view str) const -> MatchResult {
                if( match_str.size() > str.size() )
                    return false;
                return CasePolicy::equal(str.substr(0, match_str.size()), match_str);
            }
            [[nodiscard]] auto describe() const -> MatcherDescription {
                return std::format("starts_with<{}>(\"{}\")", CasePolicy::name, match_str);
            }
        };
        template<typename CasePolicy=CaseSensitive>
        struct EndsWith {
            std::string_view match_str;

            [[nodiscard]] auto match(std::string_view str) const -> MatchResult {
                if( match_str.size() > str.size() )
                    return false;
                return CasePolicy::equal(str.substr(str.size()-match_str.size()), match_str);
            }
            [[nodiscard]] auto describe() const -> MatcherDescription {
                return std::format("ends_with<{}>(\"{}\")", CasePolicy::name, match_str);
            }
        };
        template<typename CasePolicy=CaseSensitive>
        struct Contains {
            std::string_view match_str;
            [[nodiscard]] auto match( IsStringViewable auto const& str ) const -> MatchResult {
                return CasePolicy::find(str, match_str);
            }
            [[nodiscard]] auto match( NonStringRange auto const& range ) const -> MatchResult {
                // Special case where we are matching a string, but when contained within a range
                for( const auto& element : range ) {
                    if( CasePolicy::equal( match_str, element ) )
                        return true;
                }
                return false;
            }
            [[nodiscard]] auto describe() const -> MatcherDescription {
                return std::format("contains<{}>(\"{}\")", CasePolicy::name, match_str);
            }
        };

        template<typename CasePolicy=CaseSensitive>
        struct Equals {
            std::string_view match_str;

            [[nodiscard]] auto match(std::string_view str) const -> MatchResult {
                return CasePolicy::equal(str, match_str);
            }
            [[nodiscard]] auto describe() const -> MatcherDescription {
                return std::format("equals<{}>(\"{}\")", CasePolicy::name, match_str);
            }
        };


        template<typename CasePolicy=CaseSensitive>
        struct MatchesRegex {
            std::string regex_str;

            [[nodiscard]] auto match(std::string const& str) const -> MatchResult {
                return CasePolicy::matches_regex(str, regex_str);
            }
            [[nodiscard]] auto describe() const -> MatcherDescription {
                return std::format("matches_regex<{}>(\"{}\")", CasePolicy::name, regex_str);
            }
        };

    } // namespace StringMatchers

    namespace ExceptionMatchers {

        struct HasMessage {
            std::optional<std::string> what;

            [[nodiscard]] auto match(auto const& ex) const -> MatchResult {
                return what ? Detail::get_exception_message(ex) == *what : true;
            }
            template<typename BoundMatcherT>
            [[nodiscard]] auto match(auto const& ex, BoundMatcherT const& bound_matcher ) const -> CompositeMatchResult {
                static_assert(Detail::IsEagerMatcher<BoundMatcherT, std::string>);

                std::string message = Detail::get_exception_message(ex);
                if( what && message != *what )
                    return false;

                return CompositeMatchResult( bound_matcher.match(message) )
                    .set_address_of( bound_matcher )
                    .make_child_of( this );
            }

            [[nodiscard]] auto describe() const -> MatcherDescription {
                if( what )
                    return std::format("has_message(\"{}\")", *what);
                else
                    return std::format("has_message()");
            }
        };

        template<typename E=void>
        struct Throws {
            template<Detail::IsEagerMatcher<std::string> MessageMatcher>
            auto constexpr with_message_that( MessageMatcher const& message_matcher ) {
                using Detail::operator >>=;
                return *this >>= HasMessage() >>= message_matcher;
            }
            auto constexpr with_message( std::string_view message_to_match ) {
                using Detail::operator >>=;
                return *this >>= HasMessage() >>= StringMatchers::Equals{ message_to_match };
            }

            template<typename ArgT>
            [[nodiscard]] constexpr auto lazy_match(ArgT&& f) const -> CompositeMatchResult {
                return lazy_match(std::forward<ArgT>(f), Detail::AlwaysMatcher()).make_child_of(this);
            }

            template<typename BoundMatcherT>
            [[nodiscard]] constexpr auto lazy_match(auto&& f, BoundMatcherT const& bound_matcher) const -> CompositeMatchResult {
                if constexpr( std::is_void_v<E> ) {
                    try {
                        f();
                        return false;
                    }
                    catch(...) {
                        return CompositeMatchResult( bound_matcher.match(std::current_exception()) )
                            .set_address_of( bound_matcher )
                            .make_child_of(this);
                    }
                }
                else {
                    static_assert(Detail::IsEagerMatcher<BoundMatcherT, E>,
                        "The bound matcher must accept the type (or a super class of) that was detected as thrown");
                    try {
                        f();
                        return false;
                    }
                    catch(E& ex) {
                        return CompositeMatchResult( bound_matcher.match(ex) )
                            .set_address_of( bound_matcher )
                            .make_child_of( this );
                    }
                    catch(...) {
                        return false;
                    }
                }
                return false;
            }
            [[nodiscard]] auto describe() const -> MatcherDescription {
                if constexpr(std::is_void_v<E>)
                    return "throws()";
                else
                    return std::format("throws<{}>()", type_to_string<E>());
            }
        };

    } // namespace ExceptionMatchers

    namespace FloatMatchers {
        inline auto margin_compare( double lhs, double rhs, double margin ) -> bool {
            return (lhs + margin >= rhs) && (rhs + margin >= lhs);
        }

        struct IsCloseToRel {
            double target;
            double epsilon;

            [[nodiscard]] auto match( double value ) const -> MatchResult {
                if( epsilon < 0 || epsilon >= 1 )
                    throw std::domain_error( "epsilon must be positive and < 1" );
                auto rel_margin = epsilon * (std::max)(std::fabs(value), std::fabs(target));
                return margin_compare( value, target, std::isinf(rel_margin) ? 0 : rel_margin );
            }
            [[nodiscard]] auto describe() const -> MatcherDescription {
                return std::format("is_close_to({})", target);
            }
        };

        template<std::floating_point T>
        struct IsCloseToAbs {
            T target;
            double margin;

            [[nodiscard]] auto match(T value) const -> MatchResult {
                if( margin < 0 )
                    throw std::domain_error( "margin must be positive" );
                return margin_compare( value, target, margin );
            }
            [[nodiscard]] auto describe() const -> MatcherDescription {
                return std::format("is_close_to_abs({})", target);
            }
        };

        template<std::floating_point T>
        struct IsWithinUlp {
            T target;
            std::uint64_t ulps;

            static constexpr T infinity = std::numeric_limits<T>::infinity();

            [[nodiscard]] auto match(T value) const -> MatchResult {
                if constexpr( std::same_as<T, float> ) {
                    if( ulps >= (std::numeric_limits<std::uint32_t>::max)())
                        throw std::domain_error( "ulps is too large for a float" );
                }
                return value == target ||
                    ( std::nextafter( target, infinity )*ulps >= value &&
                    std::nextafter( target, -infinity )*ulps <= value );
            }
            [[nodiscard]] auto describe() const -> MatcherDescription {
                return std::format("is_within_ulp( {} )", target);
            }
        };

        struct IsNaN {
            [[nodiscard]] auto match(std::floating_point auto value) const -> MatchResult {
                return std::isnan( value );
            }
            [[nodiscard]] auto describe() const -> MatcherDescription {
                return std::format("is_nan()");
            }
        };
    } // namespace FloatMatchers


    namespace Matchers {
        using StringMatchers::CaseSensitive;
        using StringMatchers::CaseInsensitive;
        using RangeMatchers::InOrder;
        using RangeMatchers::InAnyOrder;

        auto equals(NotARange auto& value) { return GenericMatchers::Equals{value}; }

        inline auto has_size(std::size_t size) { return GenericMatchers::HasSize{size}; }

        template<typename CasePolicy=CaseSensitive>
        auto starts_with(std::string_view str) { return StringMatchers::StartsWith<CasePolicy>{str}; }

        template<typename CasePolicy=CaseSensitive>
        auto ends_with(std::string_view str) { return StringMatchers::EndsWith<CasePolicy>{str}; }

        template<typename CasePolicy=CaseSensitive>
        auto contains(IsStringViewable auto const& str) {
            return StringMatchers::Contains<CasePolicy>{ std::string_view(str) };
        }

        auto contains(NotARange auto const& element) {
            return RangeMatchers::ContainsElement{ element };
        }

        auto contains(NotStringViewable auto const& range) {
            return RangeMatchers::ContainsRange{ range };
        }

        template<typename OrderPolicy = InOrder, NonStringRange R>
        auto equals( R const& range ) {
            return RangeMatchers::Equals<OrderPolicy, R>{ range };
        }

        template<typename CasePolicy=CaseSensitive>
        auto equals(std::string_view str) { return StringMatchers::Equals<CasePolicy>{str}; }

        template<typename CasePolicy=CaseSensitive>
        auto matches_regex(std::string str) { return StringMatchers::MatchesRegex<CasePolicy>{ std::move(str) }; }

        template<std::floating_point T>
        auto is_close_to(T target, double margin = 100*std::numeric_limits<T>::epsilon() ) {
            return FloatMatchers::IsCloseToAbs{ target, margin };
        }
        template<std::floating_point T>
        auto is_close_to_rel( T target, double epsilon = 100*std::numeric_limits<T>::epsilon() ) {
            return FloatMatchers::IsCloseToRel{ target, epsilon };
        }
        auto is_within_ulp(std::floating_point auto target, std::uint64_t ulps=1) {
            return FloatMatchers::IsWithinUlp{ target, ulps };
        }
        inline auto is_nan() {
            return FloatMatchers::IsNaN();
        }

        inline auto is_true() { static bool true_value = true; return equals(true_value); }
        inline auto is_false() { static bool false_value = false; return equals(false_value); }


        template<typename E=void>
        using throws = ExceptionMatchers::Throws<E>;

        template<typename PredicateT>
        auto matches_predicate(PredicateT&& pred, std::string description = "predicate") {
            return GenericMatchers::MatchesPredicate<PredicateT>(std::forward<PredicateT>(pred), std::move(description));
        }

    } // namespace Matchers

} // namespace CatchKit


// Packed from catch23/include/catch23/adjusted_result.h
namespace CatchKit {

    // After taking account of may_fail and should_fail tags
    enum class AdjustedResult {
        Unknown,
        Passed,
        FailedExpectly, // Failed, but may_fail was in operation
        Failed
    };
} // namespace CatchKit


// Packed from catch23/include/catch23/internal_execution_nodes.h
namespace CatchKit::Detail {

    inline auto locations_are_equal(std::source_location loc1, std::source_location loc2) -> bool {
        return loc1.line() == loc2.line()
            && loc1.column() == loc2.column()
            && loc1.file_name() == loc2.file_name();
    }

    struct NodeId {
        std::string name;
        std::source_location location = std::source_location::current();

        auto operator == (NodeId const& other) const -> bool {
            return locations_are_equal( location, other.location );
        };
    };

    class ExecutionNodes;

    struct ShrinkableNode {
        virtual void start_shrinking() = 0;
        virtual void rebase_shrink() = 0;
        virtual auto stop_shrinking() -> bool = 0;
        virtual auto shrink() -> bool = 0;
        virtual auto current_value_as_string() -> std::string = 0;
    protected:
        ~ShrinkableNode() = default;
    };

    class ExecutionNode {
    public:
        enum class States {
            None, // Just added
            NotEntered, // Added on a previous cycle but not (yet) entered on this one
            Entered,
            EnteredButDoneForThisLevel,
            ExitedEarly, // through an early return or exception - including test cancellation
            HasIncompleteChildren,
            Incomplete, // Children are complete, but there are more local levels (e.g. generator values)
            Frozen, // Held in place during a shrink
            Completed
        };

    private:
        friend class ExecutionNodes;

        NodeId id; // NOLINT
        ExecutionNodes* container = nullptr;
        ExecutionNode* parent = nullptr;
        std::vector<std::unique_ptr<ExecutionNode>> children;
        States state = States::None;

        [[nodiscard]] auto get_current_node() const -> ExecutionNode*;
        auto set_current_node(ExecutionNode* node);

        ShrinkableNode* shrinkable = nullptr; // May be set by derived class
        std::size_t current_index = 0;
    protected:
        virtual void move_first() { /* may be implemented in derived class */ }
        virtual auto move_next() -> bool; // `true` means we finished
        void set_current_index(std::size_t index) { current_index = index; }
        auto increment_current_index() { return ++current_index; }
        void set_shrinkable(ShrinkableNode* node) { shrinkable = node; }
    public:
        explicit ExecutionNode( NodeId id ) : id(std::move(id)) {}
        virtual ~ExecutionNode() = default;

        [[nodiscard]] auto find_child( std::source_location loc_to_find ) const -> ExecutionNode*;
        [[nodiscard]] auto find_child(NodeId const& id_to_find) const { return find_child( id_to_find.location ); }

        auto add_child(std::unique_ptr<ExecutionNode>&& child) -> ExecutionNode& {
            child->parent = this;
            children.emplace_back( std::move(child) );
            return *children.back();
        }
        auto add_child(NodeId const& id_to_add) -> ExecutionNode&;

        [[nodiscard]] auto get_state() const { return state; }
        [[nodiscard]] auto get_parent() const { return parent; }
        [[nodiscard]] auto get_parent_state() const { return parent ? parent->get_state() : States::None; }
        [[nodiscard]] auto get_current_index() const { return current_index; }
        [[nodiscard]] auto get_shrinkable() const { return shrinkable; }

        void reset();
        void reset_children();

        void enter();
        auto exit(bool early = false) -> States;

        auto freeze() -> States;
        void unfreeze(States state);
    };

    class ExecutionNodes {
        ExecutionNode root;
        ExecutionNode* current_node;
        friend class ExecutionNode;
    public:
        explicit ExecutionNodes(NodeId root_id)
        :   root(std::move(root_id)),
            current_node(&root)
        {
            root.container = this;
        }

        auto add_node(std::unique_ptr<ExecutionNode>&& child) -> ExecutionNode&;
        auto add_node(NodeId const& id) -> ExecutionNode&;

        [[nodiscard]] auto& get_root() { return root; }
        [[nodiscard]] auto get_current_node() const { return current_node; }
        [[nodiscard]] auto find_node(NodeId const& id) const -> ExecutionNode* {
            return current_node->find_child(id);
        }
        [[nodiscard]] auto find_node(std::source_location loc) const -> ExecutionNode* {
            return current_node->find_child(loc);
        }
    };

} // namespace CatchKit::Detail



// Packed from catch23/include/catch23/test_info.h
namespace CatchKit {

    struct Tag {
        enum class Type {
            normal,
            mute, // test doesn't run by default, but can be run explicitly
            solo, // Only soloed tests are run by default
            may_fail, // If test fails, don't count it as a failed run overall
            should_fail, // If test fails count it as a pass. If it passes count as a failure.
            always_report, // Report all tests, even successful ones, regardless of flags
        };
        std::string name;
        Type type = Type::normal;
        bool ignored = false; // This means "pretend this tag doesn't exist" and is set by !

        auto operator!() const -> Tag {
            return Tag{name, type, !ignored};
        }
    };

    struct TestInfo {
        std::source_location location;
        std::string name = {};
        std::vector<Tag> tags = {};

        [[nodiscard]] auto has_tag_type(Tag::Type tag_type) const -> bool;
        [[nodiscard]] auto should_fail() const -> bool;
        [[nodiscard]] auto may_fail() const -> bool;
    };

} // namespace CatchKit


// Packed from catch23/include/catch23/internal_test.h
namespace CatchKit::Detail {
    struct Checker;

    template<typename T>
    concept TagConvertible = std::constructible_from<Tag, T>;

    struct Test {
        using TestFunction = std::function<void(Checker&)>;
        TestFunction test_fun;
        TestInfo test_info;

        Test( TestFunction&& test_fun, TestInfo&& test_info );
        Test( Test&& ) = default;

        template<TagConvertible... T>
        auto&& operator[](T&&...tags) {
            test_info.tags = std::vector{Tag{std::forward<T>(tags)}...};
            return std::move(*this);
        }
    };

    struct AutoReg {
        explicit AutoReg(Test&& test);
    };

} // CatchKit::Detail

namespace CatchKit::Tags {
    // Muted tests are not run by default, but can be run by name or tag
    inline constexpr Tag mute{"^mute", Tag::Type::mute };

    // If any tests are "soloed" then a default run will _only_ run the soloed tests
    // (solo overrides mute, so if both tags are present, the test is run)
    inline constexpr Tag solo{"^solo", Tag::Type::solo };

    // Tests that may_fail will be counted as a pass for the overall run even if they fail
    inline constexpr Tag may_fail{"^may_fail", Tag::Type::may_fail };

    // Tests that should_fail are counted as a pass for the overall run if they fail, and a fail if they pass
    inline constexpr Tag should_fail{"^should_fail", Tag::Type::should_fail };

    // Tests that always_report will report successful tests regardless of flags
    inline constexpr Tag always_report{"^always_report", Tag::Type::always_report };
}


// Packed from catch23/include/catch23/reporter.h
namespace CatchKit {

    struct AssertionInfo {
        AdjustedResult result;
        ExpressionInfo expression_info;
        std::string message;
        std::vector<CapturedVariable> variables;

        [[nodiscard]] auto failed() const { return result == AdjustedResult::Failed; }
        [[nodiscard]] auto passed() const { return !failed(); }
    };

    struct Counters {
        int passed_explicitly = 0;
        int failed_expectedly = 0;
        int failed = 0;

        [[nodiscard]] auto passed() const { return passed_explicitly + failed_expectedly; }
        [[nodiscard]] auto total() const { return passed() + failed; }
        [[nodiscard]] auto all_passed() const { return failed == 0 && failed_expectedly == 0; }

        auto& operator += ( Counters const& other ) {
            passed_explicitly += other.passed_explicitly;
            failed_expectedly += other.failed_expectedly;
            failed += other.failed;

            return *this;
        }

        friend auto operator + ( Counters const& lhs, Counters const& rhs ) {
            Counters result = lhs;
            result += rhs;
            return result;
        }
    };

    struct Reporter {
        virtual ~Reporter() = default;

        [[nodiscard]] virtual auto report_on_what() const -> ReportOn = 0;

        virtual void on_test_run_start() = 0;
        virtual void on_test_run_end() = 0;

        virtual void on_test_start( TestInfo const& test_info ) = 0;
        virtual void on_test_end( TestInfo const& test_info, Counters const& assertions ) = 0;

        virtual void on_assertion_start( AssertionContext const& context ) = 0;
        virtual void on_assertion_end( AssertionContext const& context, AssertionInfo const& assertion_info ) = 0;

        virtual void on_shrink_start() = 0;
        virtual void on_shrink_found( std::vector<std::string> const& values, int shrinks ) = 0;
        virtual void on_no_shrink_found( int shrinks ) = 0;
        virtual void on_shrink_result( ResultType result, int shrinks_so_far ) = 0;
        virtual void on_shrink_end() = 0;
    };

} // namespace CatchKit


// Packed from catch23/include/catch23/test_result_handler.h
namespace CatchKit::Detail
{
    class TestCancelled {};

    enum class ShrinkingMode { Normal, Shrinking, Shrunk, NotShrunk };

    class TestResultHandler : public ResultHandler {
        Reporter& reporter;
        std::optional<AssertionContext> current_context;
        TestInfo const* current_test_info = nullptr;
        AdjustedResult last_result = AdjustedResult::Unknown;
        ResultDisposition current_result_disposition = ResultDisposition::Abort;
        ExecutionNodes* execution_nodes = nullptr;

        std::vector<VariableCaptureRef*> variable_captures;
        Counters assertions;
        ShrinkingMode shrinking_mode = ShrinkingMode::Normal;
        int shrink_count = 0;

    public:
        explicit TestResultHandler(Reporter& reporter);

        auto operator=(TestResultHandler&&) = delete; // non-copyable, non-moveable

        void on_test_start( TestInfo const& test_info );
        void on_test_end( TestInfo const& test_info );

        void on_assertion_start( ResultDisposition result_disposition, AssertionContext const& context ) override;
        [[nodiscard]] auto on_assertion_result( ResultType result ) -> ResultDetailNeeded override;
        void on_assertion_result_detail( ExpressionInfo const& expression_info, std::string_view message ) override;
        void on_assertion_end() override;

        void on_shrink_start();
        void on_shrink_found( std::vector<std::string> const& values );
        void on_shrink_end();

        void add_variable_capture( VariableCaptureRef* capture ) override;
        void remove_variable_capture( VariableCaptureRef* capture ) override;

        [[nodiscard]] auto get_reporter() const -> Reporter& { return reporter; }
        [[nodiscard]] auto passed() const { return last_result != AdjustedResult::Failed; }
        [[nodiscard]] auto get_execution_nodes() const { return execution_nodes; }
        [[nodiscard]] auto get_assertion_counts() const { return assertions; }

        [[nodiscard]] auto get_last_known_location() const -> std::source_location;

        void set_execution_nodes( ExecutionNodes* nodes ) { execution_nodes = nodes; }
    };

    auto get_execution_nodes_from_result_handler(ResultHandler& handler) -> ExecutionNodes&;

} // namespace CatchKit::Detail

namespace CatchKit {

    using Detail::TestResultHandler;

} //namespace CatchKit


// Packed from catch23/include/catch23/sections.h
namespace CatchKit::Detail {

    struct SectionInfo {
        ExecutionNode& node;
        bool entered;

        ~SectionInfo();

        explicit operator bool() const noexcept { return entered; }
    };

    auto try_enter_section(ExecutionNodes& nodes, std::string_view name, std::source_location location = std::source_location::current()) -> SectionInfo;

} // namespace CatchKit::Detail


// Packed from catch23/include/catch23/macros.h
#define CATCH23_MAKE_TEST(fname, ...) \
    CatchKit::Detail::Test( &fname, { std::source_location::current()__VA_OPT__(, CATCHKIT_VA_MACRO_HEAD(__VA_ARGS__)) } ) CATCHKIT_VA_MACRO_TAIL(__VA_ARGS__)

#define CATCH23_INTERNAL_TEST2(fname, test_decl) \
    static void fname(CatchKit::Checker&); \
    namespace{ namespace CATCHKIT_INTERNAL_UNIQUE_NAME(reg_ns) { using namespace CatchKit::Tags; CatchKit::Detail::AutoReg auto_registrar ( test_decl ); } } /* NOLINT */ \
    CATCHKIT_WARNINGS_UNSCOPED_SUPPRESS_UNUSED_PARAMETER \
    CATCHKIT_WARNINGS_UNSCOPED_SUPPRESS_SHADOW \
    static void fname(CatchKit::Checker& checker )

#define CATCH23_INTERNAL_TEST(fname, ... ) CATCH23_INTERNAL_TEST2( fname, CATCH23_MAKE_TEST(fname, __VA_ARGS__) )

#define TEST(...) CATCH23_INTERNAL_TEST( CATCHKIT_INTERNAL_UNIQUE_NAME(catch23_test_), __VA_ARGS__ )

// Sections
#define SECTION(name) if( auto section_info = try_enter_section(CatchKit::Detail::get_execution_nodes_from_result_handler(*checker.result_handler), name) )

// Meta testing
#define LOCAL_TEST(...) CatchKit::MetaTestRunner(__VA_ARGS__) << [](CatchKit::Checker& checker)
#define RUN_TEST_BY_NAME(name) CatchKit::MetaTestRunner(name).run_test_by_name( name )

// Generators
#define GENERATE(...) \
    [&checker]{ using namespace CatchKit::Generators; \
        CatchKit::Detail::GeneratorAcquirer acquirer(checker, {#__VA_ARGS__}); \
        if( !acquirer.generator_node ) acquirer.make_generator((__VA_ARGS__)); \
        return acquirer.derived_node<decltype((__VA_ARGS__))>(); \
    }()->current_value()


// Catch2 compatibility
#define CATCH23_INTERNAL_MAKE_TEST_LEGACY(fname, ...) \
    CatchKit::Detail::Test( &fname, CatchKit::Detail::make_test_info( std::source_location::current() __VA_OPT__(, __VA_ARGS__ ) ) )
#define CATCH23_INTERNAL_TEST_LEGACY(fname, ... ) CATCH23_INTERNAL_TEST2( fname, CATCH23_INTERNAL_MAKE_TEST_LEGACY(fname, __VA_ARGS__ ) )

#define TEST_CASE(...) CATCH23_INTERNAL_TEST_LEGACY(CATCHKIT_INTERNAL_UNIQUE_NAME(catch23_test), __VA_ARGS__)



// Packed from catch23/include/catch23/test.h

// Packed from catch23/include/catch23/catch2_compat.h
namespace CatchKit::Detail {

    auto make_test_info(std::source_location location, std::string name = {}, std::string_view tag_spec = {} ) -> TestInfo;

} // namespace CatchKit::Detail


// TEST_CASE macro is now in macros.h

#define CHECK_FALSE(...) CATCHKIT_INTERNAL_ASSERT( "CHECK_FALSE", check, CatchKit::Detail::InvertResult::Yes, __VA_ARGS__ )
#define REQUIRE_FALSE(...) CATCHKIT_INTERNAL_ASSERT( "REQUIRE_FALSE", require, CatchKit::Detail::InvertResult::Yes, __VA_ARGS__ )

#ifdef FAIL
#undef FAIL
#endif
#define SUCCEED(...) CATCHKIT_INTERNAL_BOOL_ASSERT( "SUCCEED", check, true ) __VA_OPT__(<<) __VA_ARGS__
#define FAIL(...) CATCHKIT_INTERNAL_BOOL_ASSERT( "FAIL", require, false ) __VA_OPT__(<<) __VA_ARGS__


// Packed from catch23/include/catch23/colour.h
namespace CatchKit {

    enum class Colours {
        Reset = 0,
        White = Reset,
        Red,
        Green,
        Blue,
        Cyan,
        Yellow,
        Grey,

        BoldRed,
        BoldGreen,
        BoldGrey,
        BoldWhite,
        BoldYellow,
        BoldNormal
    };

    struct ColourIntent {
        static Colours FileName;
        static Colours Warning;
        static Colours ResultError;
        static Colours ResultSuccess;
        static Colours ResultExpectedFailure;

        static Colours Error;
        static Colours Success;
        static Colours Skip;

        static Colours OriginalExpression;
        static Colours ReconstructedExpression;

        static Colours SecondaryText;
        static Colours Headers;
    };

    class TextColour {
    public:
        TextColour() = default;
        explicit TextColour(Colours initial_colour) { set(initial_colour); };
        ~TextColour();

        auto operator=(TextColour&&)  = delete; // non-moveable, non-copyable

        void set(Colours colour) const;
    };

} // namespace CatchKit


// Packed from catch23/include/catch23/console_reporter.h
namespace CatchKit {

    enum class PrintSummary {
        Always, // The default
        Never,
        OnlyWhenTestsAreReported
    };

    class ConsoleReporter : public Reporter {
        TestInfo const* current_test_info = nullptr;
        bool printed_header = false;
        ReportOn what_to_report_on;
        PrintSummary print_summary;

        bool shrinking = false;

        Counters test_totals;
        Counters assertion_totals;

        void lazy_print_test_header();

    public:
        explicit ConsoleReporter( ReportOn what_to_report_on = ReportOn::FailingTests, PrintSummary print_summary = PrintSummary::Always )
        :   what_to_report_on( what_to_report_on ),
            print_summary(print_summary)
        {}

        [[nodiscard]] auto report_on_what() const -> ReportOn override {
            return what_to_report_on;
        }

        void on_test_start( TestInfo const& test_info ) override;
        void on_test_end( TestInfo const& test_info, Counters const& assertions ) override;

        void on_assertion_start( AssertionContext const& context ) override;
        void on_assertion_end( AssertionContext const& context, AssertionInfo const& assertion_info ) override;

        void on_shrink_start() override;
        void on_shrink_found( std::vector<std::string> const& values, int shrinks ) override;
        void on_no_shrink_found( int shrinks ) override;
        void on_shrink_result( ResultType result, int shrinks_so_far ) override;
        void on_shrink_end() override;

        void on_test_run_start() override;
        void on_test_run_end() override;
    };

} // namespace CatchKit


// Packed from catch23/include/catch23/print.h
namespace CatchKit {

    template<typename ...Args>
    void print( Colours colour, std::format_string<Args...> fmt, Args&&... args ) {
        TextColour colourGuard(colour);
        std::print(fmt, std::forward<Args>(args)...);
    }
    template<typename ...Args>
    void println( Colours colour, std::format_string<Args...> fmt, Args&&... args ) {
        TextColour colourGuard(colour);
        std::println(fmt, std::forward<Args>(args)...);
    }

} // namespace CatchKit


// Packed from catch23/include/catch23/random.h
namespace CatchKit::Detail {

    // !TBD This is a placeholder for a proper implementation
    // In particular the non-portable distribution is an issue
    // Should probably borrow from Martin's work on Catch2

    template<typename T>
    concept IsBuiltInNumeric = std::integral<T> || std::floating_point<T>;

    class RandomNumberGenerator {
        unsigned int seed;
        std::mt19937 mt; // !TBD Use Pcg? Philox (C++26)?
    public:
        RandomNumberGenerator()
        : RandomNumberGenerator(std::random_device()())
        {}
        explicit RandomNumberGenerator(unsigned int seed)
        :   seed(seed),
            mt(seed)
        {}

        // resets to the initial seed
        void reset() {
            mt.seed(seed);
        }

        // Returns a number between from and to, inclusive
        template<IsBuiltInNumeric NumberT>
        auto generate(NumberT from, NumberT to) -> NumberT {
            if constexpr(std::integral<NumberT>)
                return std::uniform_int_distribution<NumberT>(from, to)(mt);
            else
                return std::uniform_real_distribution<NumberT>(from, to)(mt);
        }
    };

} // namespace CatchKit::Detail


// Packed from catch23/include/catch23/generator_node.h
namespace CatchKit::Detail {

    template<typename G>
    struct shrinker_for;

    template<typename G>
    concept IsSingleValueGenerator = requires(G g, RandomNumberGenerator& rng){ { g.generate(rng) }; };

    template<typename G>
    concept IsMultiValueGenerator = requires(G const& g, std::size_t pos, RandomNumberGenerator& rng){ { g.generate_at(pos, rng) }; };

    template<typename G>
    concept IsGeneratorSized = requires(G const& g, std::size_t pos){ { g.size(pos) } -> std::same_as<std::size_t>; };

    template<typename G>
    auto size_of(G const& generator, std::size_t default_size = 100) {
        if constexpr( IsMultiValueGenerator<G> ) {
            static_assert( !IsGeneratorSized<G>, "Generator has generate_at() but not size()");
            return std::size(generator);
        }
        else
            return default_size;
    }

    template<typename G>
    auto generate_at(G const& generator, std::size_t pos, RandomNumberGenerator& rng) {
        if constexpr( IsSingleValueGenerator<G> )
            return generator.generate(rng);
        else if constexpr( IsMultiValueGenerator<G> )
            return generator.generate_at(pos, rng);
        else
            static_assert(false, "not a generator");
    }

    constexpr std::size_t default_repetitions = 100; // Make this runtime configurable?

    auto make_dummy_rng() -> RandomNumberGenerator&;

    template<typename GeneratorType>
    using get_generated_type = decltype(generate_at(std::declval<GeneratorType>(), 0, make_dummy_rng()));

    template<typename G>
    concept IsGeneratorShrinkable = requires(G& g, get_generated_type<G> val){ { shrinker_for<G>().shrink(g, val) }; };


    // This is a dummy implementation that saves us having to constexpr guard calls that aren't taken
    template<typename GeneratorType, typename GeneratedType>
    struct Shrinker {
        GeneratedType original_failing_value;
        explicit Shrinker(GeneratorType const&, GeneratedType const&, std::set<GeneratedType>&) {}
        static void rebase() { /* no impl needed here */ }
        [[nodiscard]] static auto shrink() -> bool { return false; }
    };

    template<IsGeneratorShrinkable GeneratorType, typename GeneratedType>
    struct Shrinker<GeneratorType, GeneratedType> {
        GeneratorType& generator;
        GeneratedType& current_value;
        GeneratedType original_failing_value;
        shrinker_for<GeneratorType> shrinker;
        std::optional<std::generator<GeneratedType>> shrink_generator;
        using iterator = decltype(shrink_generator->begin());
        iterator it;
        std::set<GeneratedType>& cache;

        Shrinker(GeneratorType& generator, GeneratedType& current_value, std::set<GeneratedType>& cache)
        :   generator(generator),
            current_value(current_value),
            original_failing_value(current_value),
            shrink_generator( shrinker.shrink( generator, original_failing_value ) ),
            it( shrink_generator->begin() ),
            cache(cache)
        {}
        void rebase() {
            original_failing_value = current_value;
            shrink_generator.reset();
            shrinker.rebase();
            shrink_generator = shrinker.shrink( generator, original_failing_value );
            it = shrink_generator->begin();
        }
        [[nodiscard]] auto shrink() -> bool {
            while( it != shrink_generator->end() ) {
                current_value = *it;
                ++it;
                if( !cache.contains( current_value ) ) {
                    if( cache.size() < 10 )
                        cache.insert( current_value );
                    // std::print("trying: {} ", current_value);
                    return true;
                }
            }
            return false;
        }
    };


    // Typed generator holder node
    template<typename GeneratorType>
    class GeneratorNode : public ExecutionNode, public ShrinkableNode {
        GeneratorType generator;
        RandomNumberGenerator rng;
        std::size_t size;
        using GeneratedType = get_generated_type<GeneratorType>;
        GeneratedType current_generated_value;
        std::optional<GeneratedType> pre_shrunk_value;
        std::optional<Shrinker<GeneratorType, GeneratedType>> shrinker;
        std::set<GeneratedType> cache;
    public:
        explicit GeneratorNode( NodeId const& id, GeneratorType&& gen )
        :   ExecutionNode(id),
            generator(std::move(gen)),
            size(size_of(generator, default_repetitions)),
            current_generated_value( generate_value() )
        {
            if( IsGeneratorShrinkable<GeneratorType> ) {
                set_shrinkable(this);
            }
        }

        auto generate_value() {
            return generate_at(generator, get_current_index(), rng);
        }
        void move_first() override {
            assert( !shrinker );
            rng.reset();
            current_generated_value = generate_value();
        }
        auto move_next() -> bool override {
            assert( !shrinker );
            if( increment_current_index() == size )
                return true;
            current_generated_value = generate_value();
            return false;
        }

        GeneratedType& current_value() {
            return current_generated_value;
        }

        // ShrinkableNode interface:
        void start_shrinking() override {
            pre_shrunk_value = current_generated_value;
            shrinker.emplace( generator, current_generated_value, cache );
        }
        void rebase_shrink() override {
            assert( shrinker );
            shrinker->rebase();
        }

        auto shrink() -> bool override {
            assert(shrinker);
            return shrinker->shrink();
        }

        auto stop_shrinking() -> bool override {
            assert(shrinker);
            current_generated_value = shrinker->original_failing_value;
            bool shrunk = (pre_shrunk_value != current_generated_value);
            shrinker.reset();
            pre_shrunk_value.reset();
            set_current_index(size-1);
            return shrunk;

        }
        auto current_value_as_string() -> std::string override {
            return stringify(current_generated_value);
        }
    };


    struct GeneratorAcquirer {
        ExecutionNodes& execution_nodes;
        NodeId id;
        ExecutionNode* generator_node;

        GeneratorAcquirer(Checker const& checker, NodeId&& id)
        :   execution_nodes(get_execution_nodes_from_result_handler(*checker.result_handler)),
            id(std::move(id)),
            generator_node(execution_nodes.find_node(this->id))
        {}

        template<typename T>
        void make_generator(T&& gen) {
            generator_node = &execution_nodes.add_node( std::make_unique<GeneratorNode<T>>(id, std::forward<T>(gen)) );
        }
        template<typename T>
        auto derived_node() {
            assert(generator_node != nullptr);
            generator_node->enter(); // NOLINT (we just checked it wasn't null!)
            return static_cast<GeneratorNode<T>*>(generator_node);
        }
    };

} // namespace CatchKit::Detail



// Packed from catch23/include/catch23/generators.h
namespace CatchKit {

    namespace Detail {

        // To provide your own generators, either:
        // 1. specialise values_of for your type and generate_value for valuesOf<your type>, or
        // 2. for something more general/ operators on multiple values, specialise size_of and generate_at

        template<typename> struct values_of {}; // Specialise this for your own types


        // Adapter to specify number of repetitions:

        template<typename T>
        struct multiple_values {
            std::size_t multiple;
            values_of<T> value_generator;

            auto generate_at( std::size_t, RandomNumberGenerator& rng ) const { return value_generator.generate(rng); }
            auto size() const { return multiple; }

            template<typename U>
            auto shrink(U&& value) -> std::generator<T> requires IsGeneratorShrinkable<values_of<T>> {
                return value_generator.shrink(std::forward<U>(value));
            }
        };

        template<typename T> requires IsGeneratorShrinkable<values_of<T>>
        struct shrinker_for<multiple_values<T>> : shrinker_for<values_of<T>> {
            template<typename U>
            auto shrink( multiple_values<T>& generator, U&& value ) -> std::generator<T> {
                return shrinker_for<values_of<T>>::shrink( generator.value_generator, std::forward<U>(value) );
            }
        };

        template<typename T>
        constexpr auto operator, ( std::size_t multiple, values_of<T>&& values ) {
            return multiple_values<T>{ multiple, std::move(values) };
        }


        // Numeric (int or real) generators:

        template<IsBuiltInNumeric T>
        struct values_of<T> {
            T from {};
            T up_to = std::numeric_limits<T>::max();

            [[nodiscard]] auto generate( RandomNumberGenerator& rng ) const { return rng.generate(from, up_to); }

        };

        template<IsBuiltInNumeric T>
        struct shrinker_for<values_of<T>> {

            enum class Strategies {
                SimpleValues,
                BinaryDescent,
                Ladder1000,
                Ladder100,
                Ladder10,
                Ladder1
            };
            Strategies strategy = Strategies::SimpleValues;

            void rebase() {
                // if( strategy == Strategies::SimpleValues )
                    strategy = Strategies::BinaryDescent;
            }
            auto shrink( values_of<T>& generator, T value ) -> std::generator<T> { // NOSONAR NOLINT (misc-typo)
                if( value >= 0 ) {
                    switch( strategy ) {
                    case Strategies::SimpleValues:
                        co_yield 0;

                        if( value > 1 )
                            co_yield 1;
                        if( value > 2 )
                            co_yield 2;
                        strategy = Strategies::BinaryDescent;
                        [[fallthrough]];
                    case Strategies::BinaryDescent:
                        if( value > 8 )
                            co_yield value/2;
                        strategy = Strategies::Ladder1000;
                        [[fallthrough]];
                    case Strategies::Ladder1000:
                        if( value > 2000 )
                            co_yield value-1000;
                        strategy = Strategies::Ladder100;
                        [[fallthrough]];
                    case Strategies::Ladder100:
                        if( value > 200 )
                            co_yield value-100;
                        strategy = Strategies::Ladder10;
                        [[fallthrough]];
                    case Strategies::Ladder10:
                        if( value > 20 )
                            co_yield value-10;
                        strategy = Strategies::Ladder1;
                        [[fallthrough]];
                    default:
                        if( value > 3 )
                            co_yield --value;
                    }
                }
                else {
                    if constexpr( std::is_signed_v<T> ) {
                        if( strategy == Strategies::SimpleValues ) {
                            co_yield -value;

                            // Explicitly yield a positive 0 for floating point, too
                            if constexpr( std::is_floating_point_v<T> ) // NOSONAR NOLINT (misc-typo)
                                co_yield 0;
                        }
                        // Mirror positive shrinks
                        for(T i: shrink(generator, -value))
                            co_yield -i;
                    }
                }
            }
        };

        template<IsBuiltInNumeric T>
        struct inclusive_range_of {
            T from {};
            T to = std::numeric_limits<T>::max();

            [[nodiscard]] auto generate_at( std::size_t index, RandomNumberGenerator const& ) const { return from + static_cast<T>(index); }
            auto size() const { assert(to > from); return 1 + to - from; }
        };

        // String generator:

        namespace Charsets {
            extern std::string const lcase; // NOLINT (misc-typo)
            extern std::string const ucase; // NOLINT (misc-typo)
            extern std::string const all_alpha;
            extern std::string const numbers;
            extern std::string const alphanumeric;
            extern std::string const word_chars;
            extern std::string const symbols;
            extern std::string const printable_ascii;
        }

        template<>
        struct values_of<std::string> {
            std::size_t min_len = 0;
            std::size_t max_len = 65;
            std::string_view charset = Charsets::word_chars; // Must be from string literal

            [[nodiscard]] auto generate( RandomNumberGenerator& rng ) const -> std::string;
        };


        // Generate specific values:

        template<typename T>
        struct from_values {
            std::vector<T> values;

            auto generate_at( std::size_t pos, RandomNumberGenerator const& ) const { return values[pos]; }
            auto size() const { return values.size(); }

        };
        template<typename T>
        from_values(std::initializer_list<T> values) -> from_values<T>;

        // Vector generators

        template<typename T>
        struct values_of<std::vector<T>> {
            std::size_t min_size = 0;
            std::size_t max_size = 65;
            values_of<T> value_generator;

            [[nodiscard]] auto generate( RandomNumberGenerator& rng ) const {
                std::vector<T> values( rng.generate( min_size, max_size ) );
                std::ranges::generate(values, [generator=value_generator, &rng]{ return generator.generate(rng); });
                return values;
            }
        };

    } // namespace Detail

    namespace Generators {

        namespace Charsets = Detail::Charsets;

        // Built in matchers
        using Detail::values_of;
        using Detail::from_values;
        using Detail::inclusive_range_of;

    } // namespace Generators

} // namespace CatchKit


// Packed from catch23/include/catch23/test_registry.h
namespace CatchKit::Detail {

    class TestRegistry {
        std::vector<Test> all_tests;
        std::unordered_map<std::string, std::size_t> tests_by_name;
    public:
        explicit TestRegistry( std::vector<Test>&& tests );

        auto get_all_tests() const -> std::vector<Test> const& {
            return all_tests;
        }
        auto find_test_by_name( std::string const& name ) const -> Test const*;

        auto find_tests_by_tag( std::string tag_name ) const -> std::generator<Test const*>;
        auto find_all_tests_by_tag( std::string tag_name ) const {
            return find_tests_by_tag( std::move(tag_name) ) | std::ranges::to<std::vector>();
        }
    };

    void register_test( Test&& test );
    auto get_test_registry() -> TestRegistry const&;

} // namespace CatchKit

namespace CatchKit {
    using Detail::TestRegistry;
    using Detail::get_test_registry;
}


// Packed from catch23/include/catch23/main.h
#define CATCH23_MIN_MAIN(...) \
    int main() { \
        auto reporter = CatchKit::ConsoleReporter(__VA_ARGS__); \
        CatchKit::TestRunner runner(reporter); \
        runner.run_tests(CatchKit::get_test_registry()); \
    }

#ifdef CATCH23_IMPL_MIN_MAIN
#define CATCHKIT_IMPL
#endif


// Packed from catch23/include/catch23/meta_test.h
namespace CatchKit {

    struct FullAssertionInfo {
        AssertionContext context;
        AssertionInfo info;

        [[nodiscard]] auto passed() const { return info.passed(); }
        [[nodiscard]] auto failed() const { return info.failed(); }
        [[nodiscard]] auto failed_expectedly() const { return info.result == AdjustedResult::FailedExpectly; }
    };

    class MetaTestReporter : public Reporter { // NOSONAR NOLINT (misc-typo)
        ReportOn what_to_report_on;

    public:
        explicit MetaTestReporter( ReportOn what_to_report_on = ReportOn::AllResults )
        : what_to_report_on( what_to_report_on )
        {}

        [[nodiscard]] auto report_on_what() const -> ReportOn override {
            return what_to_report_on;
        }
        void on_test_run_start() override { /* no impl */ }
        void on_test_run_end() override { /* no impl */ }

        void on_test_start( TestInfo const& ) override { /* no impl */ }
        void on_test_end( TestInfo const&, Counters const& ) override { /* no impl */ }

        void on_assertion_start( AssertionContext const& ) override { /* no impl */ }
        void on_assertion_end( AssertionContext const& context, AssertionInfo const& assertion_info ) override {
            results.emplace_back(context, assertion_info);
        }
        void on_shrink_start() override { /* no impl */ }
        void on_shrink_found( std::vector<std::string> const&, int ) override { /* no impl */ }
        void on_no_shrink_found( int ) override { /* no impl */ }
        void on_shrink_result( ResultType, int ) override { /* no impl */ }
        void on_shrink_end() override { /* no impl */ }

        std::vector<FullAssertionInfo> results;
    };

    struct MetaTestResults {
        std::vector<FullAssertionInfo> all_results;

        [[nodiscard]] auto size() const { return all_results.size(); }
        [[nodiscard]] auto& operator[](std::size_t index) const { return all_results.at(index); }
        [[nodiscard]] auto failed() const {
            return !all_results.empty() && all_results.back().failed();
        }
        [[nodiscard]] auto passed() const {
            return !all_results.empty() && all_results.back().passed();
        }
        [[nodiscard]] auto message() const {
            return !all_results.empty() ? all_results.back().info.message : std::string();
        }
        [[nodiscard]] auto failures() const -> int;
        [[nodiscard]] auto expected_failures() const -> int;
    };

    class MetaTestRunner {
        MetaTestReporter reporter;

        std::string name;
        std::source_location location;

    public:
        explicit MetaTestRunner(std::string name = "local test", std::source_location location = std::source_location::current());
        auto run( Detail::Test const& test ) && -> MetaTestResults;
        auto run_test_by_name( std::string const& name_to_find ) && -> MetaTestResults;

        friend auto operator << ( MetaTestRunner&& runner, std::invocable<Checker&> auto const& test_fun ) {
            return std::move(runner).run(Detail::Test{test_fun, {runner.location, std::move(runner.name)}});
        }
    };

} // namespace CatchKit


// Packed from catch23/include/catch23/runner.h
namespace CatchKit::Detail {

    template<typename R, typename T>
    concept range_of = std::ranges::range<R> &&
                       std::same_as<std::ranges::range_value_t<R>, T>;

    class TestRunner {
        TestResultHandler result_handler;
    public:
        explicit TestRunner( Reporter& reporter ) : result_handler(reporter) {}

        void run_test( Test const& test );

        void run_tests( TestRegistry const& tests );

        void run_tests( range_of<Test> auto const& tests ) {
            result_handler.get_reporter().on_test_run_start();

            std::vector<Test const*> tests_to_run;
            bool soloing = false;
            for( auto&& test : tests) {
                if( test.test_info.has_tag_type(Tag::Type::solo) ) {
                    if( !soloing ) {
                        tests_to_run.clear();
                        soloing = true;
                    }
                    tests_to_run.push_back( &test );
                }
                else if( !soloing && !test.test_info.has_tag_type(Tag::Type::mute) ) {
                    tests_to_run.push_back( &test );
                }
            }
            if( soloing )
                println( ColourIntent::Warning, "\nWarning: Running soloed test(s) (tests with the [solo] tag) only.\n");
            for( auto const test : tests_to_run) {
                run_test( *test );
            }

            result_handler.get_reporter().on_test_run_end();
        }
    };

} // namespace CatchKit::Detail

namespace CatchKit {
    using Detail::TestRunner;
}

// From source files:
#ifdef CATCHKIT_IMPL

// System includes (for impl):
#include <optional>
#include <regex>


// Packed from catchkit/src/assert_result_handler.cpp
namespace CatchKit::Detail {

    void AssertResultHandler::on_assertion_start( ResultDisposition result_disposition, AssertionContext const& context ) {
        current_context = context;
        current_result_disposition = result_disposition;
    }

    auto AssertResultHandler::on_assertion_result( ResultType result ) -> ResultDetailNeeded {
        last_result = result;
        if( last_result == ResultType::Passed )
            return ResultDetailNeeded::No;
        return ResultDetailNeeded::Yes;
    }
    void AssertResultHandler::on_assertion_result_detail( ExpressionInfo const& expression_info, std::string_view message ) {
        // !TBD When we can use stacktrace do something like this:
        // https://godbolt.org/z/jM4TnaMEW

        // Redundant?
        auto os = stdout;
        if (last_result != ResultType::Passed )
            os = stderr;

        std::println(os, "{}:{}:{}: in function '{}'",
                current_context.location.file_name(),
                current_context.location.line(),
                current_context.location.column(),
                current_context.location.function_name());
        std::string_view macro_name = current_context.macro_name;
        if ( macro_name.empty() )
            macro_name = "assertion";
        if ( !current_context.original_expression.empty() )
            std::println(os, "{} {} for expression:\n\t{}",
                macro_name, (last_result == ResultType::Passed) ? "passed" : "failed",
                current_context.original_expression);
        else
            std::println(os, "{} {}",
                macro_name, (last_result == ResultType::Passed) ? "passed" : "failed");

        if( last_result == ResultType::Failed ) {
            if( auto except_expr = std::get_if<ExceptionExpressionInfo>( &expression_info ) ) {
                switch( except_expr->type ) {
                    case ExceptionExpressionInfo::Type::Missing:
                        std::println(os, "due to a missing exception");
                        break;
                case ExceptionExpressionInfo::Type::Unexpected:
                    std::println(os, "due to an unexpected exception");
                    break;
                default:
                    assert( false );
                }
            }
        }
        if(!std::holds_alternative<std::monostate>(expression_info))
            std::println(os, "with expansion:\n\t{}", expression_info );

        if (!message.empty()) {
            std::println(os, "with message:\n\t{}", message);
        }
    }
    void AssertResultHandler::on_assertion_end() {
        if ( last_result != ResultType::Passed && current_result_disposition == ResultDisposition::Abort ) {
            std::terminate();
        }
    }

} // namespace CatchKit::Detail

// Packed from catchkit/src/checker.cpp
namespace {
    CatchKit::Detail::AssertResultHandler default_assertion_handler; // NOSONAR NOLINT (misc-typo)
}

constinit CatchKit::Checker checker{ &default_assertion_handler }; // NOSONAR NOLINT (misc-typo)

namespace CatchKit::Detail {

    auto Checker::check(AssertionContext const& context, InvertResult invert_result) -> Asserter {
        result_handler->on_assertion_start(ResultDisposition::Continue, context);
        return Asserter( *this, invert_result );
    }
    auto Checker::require(AssertionContext const& context, InvertResult invert_result) -> Asserter {
        result_handler->on_assertion_start(ResultDisposition::Abort, context);
        return Asserter( *this, invert_result );
    }

    Asserter::Asserter( Checker& checker, InvertResult invert_result ) : checker(checker), invert_result(invert_result) {
        if( checker.message_stream )
            checker.message_stream->clear();
    }
    Asserter::~Asserter() noexcept(false) {
        if( expression_info ) {
            if( checker.message_stream )
                checker.result_handler->on_assertion_result_detail( *expression_info, checker.message_stream->str() );
            else
                checker.result_handler->on_assertion_result_detail( *expression_info, {} );
        }

        checker.result_handler->on_assertion_end(); // This may throw to cancel the test
    }

    void Asserter::report_current_exception() const {
        if( checker.result_handler->on_assertion_result(ResultType::Failed) == ResultDetailNeeded::Yes ) {
            checker.result_handler->on_assertion_result_detail(
                ExceptionExpressionInfo{
                    get_exception_message(
                        std::current_exception()),
                        ExceptionExpressionInfo::Type::Unexpected },
                    {} );
        }
    }


} // namespace CatchKit::Detail

// Packed from catchkit/src/exceptions.cpp
namespace CatchKit::Detail {

    const std::string unknown_exception_message = "<unknown exception type>";

    [[nodiscard]] auto get_exception_message( std::exception const& ex ) -> std::string {
        return ex.what();
    }
    [[nodiscard]] auto get_exception_message( std::string const& str ) -> std::string {
        return str;
    }

    [[nodiscard]] auto get_exception_message( std::exception_ptr const& ex ) -> std::string {
        std::string message;
        try {
            std::rethrow_exception(ex);
        }
        catch(std::exception& e) { // NOSONAR NOLINT (misc-typo)
            return get_exception_message(e);
        }
        catch (std::string& s) {
            return get_exception_message(s);
        }
        catch(...) { // NOSONAR NOLINT (misc-typo)
            // !TBD: registry for custom exception translations
            return unknown_exception_message;
        }
    }
    [[nodiscard]] auto get_current_exception_message() -> std::string {
        return get_exception_message(std::current_exception());
    }

} // namespace CatchKit::Detail
// Packed from catchkit/src/expression_info.cpp
std::format_context::iterator std::formatter<CatchKit::ExpressionInfo>::format(CatchKit::ExpressionInfo const& expr, std::format_context& ctx) {
    using namespace CatchKit;

    return std::visit(
        [&]<typename T>(T const& expr_inner) -> std::format_context::iterator {
            if constexpr(std::is_same_v<T, UnaryExpressionInfo>)
                return std::format_to( ctx.out(), "{}", expr_inner.value );
            if constexpr(std::is_same_v<T, BinaryExpressionInfo>)
                return std::format_to( ctx.out(), "{} {} {}", expr_inner.lhs, expr_inner.op, expr_inner.rhs );
            if constexpr(std::is_same_v<T, MatchExpressionInfo>)
                return std::format_to( ctx.out(), "{} {}", expr_inner.candidate_value, expr_inner.matcher );
            if constexpr(std::is_same_v<T, ExceptionExpressionInfo>)
                return std::format_to( ctx.out(), "{}", expr_inner.exception_message );
            assert(false);
    }, expr);
}

// Packed from catchkit/src/internal_matchers.cpp
namespace CatchKit::Detail {

    void MatchResult::set_address( uintptr_t address ) {
        assert(matcher_address == 0 || matcher_address == address);
        matcher_address = address;
    }

    auto CompositeMatchResult::add_children_from(CompositeMatchResult const& other) -> CompositeMatchResult&& {
        child_results.reserve( child_results.size() + other.child_results.size() );
        std::ranges::copy( other.child_results, std::back_inserter( child_results ) );
        return std::move(*this);
    }

    auto CompositeMatchResult::make_child_of(uintptr_t address) -> CompositeMatchResult&& {
        child_results.emplace_back( result, std::exchange( matcher_address, address ) );
        return std::move(*this);
    }

} // namespace CatchKit::Detail
// Packed from catchkit/src/matchers.cpp
namespace CatchKit {

    // !TBD: test the others
    static_assert(Detail::IsMatcher<GenericMatchers::Equals<bool>>);
    static_assert(Detail::IsEagerMatcher<ExceptionMatchers::HasMessage, std::domain_error>);
    static_assert(Detail::IsMatcher<ExceptionMatchers::HasMessage>);
    static_assert( Detail::IsCompositeMatcher<Detail::AndMatcher<GenericMatchers::Equals<bool>, GenericMatchers::Equals<bool>>> );

    namespace StringMatchers {

        bool CaseSensitive::equal(std::string_view str1, std::string_view str2) {
            return str1 == str2;
        }
        bool CaseSensitive::find(std::string_view str, std::string_view substr) {
            return str.contains(substr);
        }
        bool CaseInsensitive::equal(std::string_view str1, std::string_view str2) {
            return std::ranges::equal(str1, str2,
                [](char a, char b) {
                    return std::tolower(a) == std::tolower(b);
                });
        }
        bool CaseInsensitive::find(std::string_view str, std::string_view substr) {
            return !std::ranges::search(str, substr,
                [](char a, char b) {
                    return std::tolower(a) == std::tolower(b);
                }).empty();
        }

        bool CaseSensitive::matches_regex(std::string const& str, std::string const& regex_str) {
            return std::regex_match(str, std::regex(regex_str));
        }
        bool CaseInsensitive::matches_regex(std::string const& str, std::string const& regex_str) {
            return std::regex_match(str, std::regex(regex_str, std::regex::icase));
        }

    } // namespace StringMatchers

    namespace Detail {
        void add_subexpressions( std::vector<SubExpressionInfo>& sub_expressions, CompositeMatchResult const& results, uintptr_t matcher_address, std::string const& description ) {
            if( auto it = std::ranges::find( results.child_results, matcher_address, &SubExpression::matcher_address ); it != results.child_results.end() )
                sub_expressions.emplace_back(description, it->result);
        }
    } // namespace Detail

} // namespace CatchKit
// Packed from catchkit/src/reflection.cpp
namespace CatchKit::Detail {

    auto parse_templated_name_from_function_name( std::string const& templated_name, std::string_view function_name ) -> std::string_view {
        if( auto start = function_name.find(templated_name + " = "); start != std::string_view::npos ) {
            start += templated_name.size() + 3;
            if( auto end = function_name.find_first_of("];", start); end != std::string_view::npos )
                return function_name.substr(start, end-start);
        }
        return {};
    }
    auto parse_templated_name( std::string const& templated_name, std::source_location location ) -> std::string_view {
        return parse_templated_name_from_function_name( templated_name, location.function_name() );
    }
    auto parse_enum_name_from_function(std::string_view function_name, bool fully_qualified) -> std::string_view {
        auto qualified_enum_name = parse_templated_name_from_function_name("candidate", function_name);
        if( auto comma = qualified_enum_name.find_first_of(','); comma != std::string_view::npos )
            qualified_enum_name = qualified_enum_name.substr(0, comma);
        if( fully_qualified )
            return qualified_enum_name; // NOLINT
        if( auto last_colon = qualified_enum_name.find_last_of(':'); last_colon != std::string_view::npos )
            return qualified_enum_name.substr(last_colon+1);
        return qualified_enum_name; // NOLINT
    }
    auto unknown_enum_to_string(size_t enum_value) -> std::string {
        return std::format("<unknown enum value: {}>", enum_value);
    }

    auto normalise_type_name(std::string_view type_name) -> std::string {
        if( type_name.starts_with("std::") ) {
            auto substr = type_name.substr(5);
            if( auto pos = substr.find( "basic_" ); pos != std::string_view::npos ) {
                substr = substr.substr(pos+6);
                if( substr.starts_with( "string<wchar_t>" ) )
                    return "std::wstring";
                if( substr.starts_with( "string_view<wchar_t>" ) )
                    return "std::wstring_view";

                if( substr.starts_with( "string<char8_t>" ) )
                    return "std::u8string";
                if( substr.starts_with( "string_view<char8_t>" ) )
                    return "std::u8string_view";

                if( substr.starts_with( "string<char16_t>" ) )
                    return "std::u16string";
                if( substr.starts_with( "string_view<char16_t>" ) )
                    return "std::u16string_view";
            }
        }
        return std::string(type_name);
    }

} // namespace CatchKit::Detail

// Packed from catchkit/src/result_handler.cpp
namespace CatchKit::Detail
{
    ResultHandler::~ResultHandler() = default;

} // namespace CatchKit::Detail
// Packed from catchkit/src/stringify.cpp
namespace CatchKit {
    auto pointer_to_string( std::uintptr_t p ) -> std::string {
        return std::format("{:#x}", p);
    }
    auto member_pointer_to_string(void const* p, std::size_t size) -> std::string {
        auto bytes = static_cast<unsigned char const*>(p);

        std::string result = "0x";
        for (size_t i = 0; i < size; ++i)
            result += std::format("{:02x}", bytes[i]);
        return result;
    }
}

// Packed from catchkit/src/variable_capture_ref.cpp
namespace CatchKit::Detail {

    VariableCaptureRef::VariableCaptureRef(std::string_view name, std::string_view type, Checker& checker)
    : name(name), type(type), result_handler(*checker.result_handler) {
        result_handler.add_variable_capture(this);
    }
    VariableCaptureRef::~VariableCaptureRef() {
        result_handler.remove_variable_capture(this);
    }

} // namespace CatchKit::Detail

// Packed from catch23/src/catch2_compat.cpp
namespace CatchKit::Detail {
    auto make_test_info(std::source_location location, std::string name, std::string_view tag_spec ) -> TestInfo {

        // Parse tags out of the tag string
        std::vector<Tag> tags;
        while(true) {
            auto start = tag_spec.find('[');
            if( start == std::string::npos )
                break;
            auto end = tag_spec.find(']', start);
            if( end == std::string::npos )
                throw std::invalid_argument("Invalid tag specification - missing an expected `]`");
            std::string tag_name(tag_spec.substr( start+1, end-start-1 ));
            if( tag_name == "!mayfail" ) // NOLINT (misc-typo)
                tags.emplace_back(Tags::may_fail);
            if( tag_name == "!shouldfail" ) // NOLINT (misc-typo)
                tags.emplace_back(Tags::should_fail);
            else if( tag_name.starts_with( "." ) )
                tags.emplace_back(tag_name, Tag::Type::mute);
            else
                tags.emplace_back(std::move(tag_name));
            tag_spec = tag_spec.substr(end);
        }

        return { location, std::move(name), std::move(tags) };
    }

} // namespace CatchKit::Detail

// Packed from catch23/src/colour.cpp
#if !(defined(__DJGPP__) && defined(__STRICT_ANSI__))
#  include <unistd.h>
#endif

namespace CatchKit {
    namespace Detail {
        bool is_colour_available() {
            static bool colour_available =
#if !(defined(__DJGPP__) && defined(__STRICT_ANSI__))
                isatty(STDOUT_FILENO) // NOLINT (misc-typo)
#endif
#if defined(CATCHKIT_PLATFORM_APPLE)
            && !isDebuggerActive()
#endif
            ;
            return colour_available;
        }
    } // namespace Detail

    TextColour::~TextColour() {
        set(Colours::Reset); // NOSONAR NOLINT (misc-typo)
    }

    void TextColour::set( Colours colour ) const { // NOLINT
        if ( Detail::is_colour_available() ) {
            std::print("\o{33}[0;{}m", [colour]() { // NOSONAR NOLINT (misc-typo)
                switch( colour )
                {
                    using enum Colours;
                    case Reset:     return "0;39";
                    case Red:       return "0;31";
                    case Green:     return "0;32";
                    case Blue:      return "0;34";
                    case Cyan:      return "0;36";
                    case Yellow:    return "0;33";
                    case Grey:      return "1;30";

                    case BoldGrey:      return "0;37";
                    case BoldRed:       return "1;31";
                    case BoldGreen:     return "1;32";
                    case BoldWhite:     return "1;37";
                    case BoldYellow:    return "1;33";
                    case BoldNormal:    return "1;39";
                    default:
                        assert(false);
                }
            }());
        }
    }

    Colours ColourIntent::Error = Colours::BoldRed;
    Colours ColourIntent::Success = Colours::Green;
    Colours ColourIntent::Warning = Colours::BoldYellow;
    Colours ColourIntent::Skip = Colours::BoldGrey;

    Colours ColourIntent::FileName = Colours::BoldGrey;
    Colours ColourIntent::ResultError = Colours::BoldRed;
    Colours ColourIntent::ResultSuccess = Colours::BoldGreen;
    Colours ColourIntent::ResultExpectedFailure = Warning;

    Colours ColourIntent::OriginalExpression = Colours::Cyan;
    Colours ColourIntent::ReconstructedExpression = Colours::BoldYellow;

    Colours ColourIntent::SecondaryText = Colours::BoldWhite;
    Colours ColourIntent::Headers = Colours::White;

} // namespace CatchKit

// Packed from catch23/src/console_reporter.cpp
namespace CatchKit {

    constexpr int console_width = 80; // !TBD: detect/ make configurable


    void print_totals_divider(Counters const& totals) {
        if (totals.total() > 0) {
            int passed_segments = console_width * totals.passed() / totals.total();
            int failed_segments = console_width * totals.failed / totals.total();
            if( passed_segments + failed_segments < console_width ) {
                if( passed_segments > failed_segments )
                    failed_segments++;
                else
                    passed_segments++;
            }

            print( ColourIntent::ResultError, "{}", std::string( failed_segments, '=' ) );
            print( ColourIntent::ResultSuccess, "{}", std::string( passed_segments, '=' ) );
            std::println();
        }
    }

    void ConsoleReporter::lazy_print_test_header() {
        if( !printed_header ) {
            assert(current_test_info);
            if( !shrinking ) {
                std::println("-------------------------------------------------------------------------------");
                println(ColourIntent::Headers, "TEST: {}", current_test_info->name);
                std::println("{}:{}",
                        current_test_info->location.file_name(),
                        current_test_info->location.line());
                std::println("...............................................................................");
            }
            std::println();
            printed_header = true;
        }
    }
    void ConsoleReporter::on_test_start( TestInfo const& test_info ) {
        current_test_info = &test_info;
        printed_header = false;
    }
    void ConsoleReporter::on_test_end( TestInfo const&, Counters const& assertions ) {
        if( assertions.failed == 0 ) {
            if( assertions.failed_expectedly == 0 )
                test_totals.passed_explicitly++;
            else
                test_totals.failed_expectedly++;
        }
        else
            test_totals.failed++;
        assertion_totals += assertions;
        current_test_info = nullptr;
    }

    void ConsoleReporter::on_assertion_start( AssertionContext const& ) { /* Not implemented for now */ }

    void ConsoleReporter::on_assertion_end( AssertionContext const& context, AssertionInfo const& assertion_info ) { // NOSONAR NOLINT (misc-typo)
        assert(current_test_info);
        lazy_print_test_header();
        std::print( "{}:{}:{}: ",
                context.location.file_name(),
                context.location.line(),
                context.location.column());
        if( assertion_info.passed() ) {
            if( assertion_info.result == AdjustedResult::FailedExpectly )
                println( ColourIntent::Warning, "🫡 FAILED, but ok" );
            else if( current_test_info->should_fail() )
                println( ColourIntent::Success, "👍 FAILED as expected" );
            else
                println( ColourIntent::Success, "👍 PASSED" );
        }
        else {
            if( current_test_info->should_fail() )
                println( ColourIntent::Error, "🤦 PASSED - but expected failure" );
            else
                println( ColourIntent::Error, "❌ FAILED" );
        }

        if( !context.original_expression.empty() )
            std::println( "for expression:" );

        if( context.macro_name.empty() ) {
            if( !context.original_expression.empty() )
                println( ColourIntent::OriginalExpression, "  {}", context.original_expression );
        }
        else {
            if( !context.original_expression.empty() )
                println( ColourIntent::OriginalExpression, "  {}( {} )", context.macro_name, context.original_expression );
            else
                println( ColourIntent::OriginalExpression, "  for {}()", context.macro_name );
        }

        if( auto const& expr_info = assertion_info.expression_info;
                !std::holds_alternative<std::monostate>( expr_info ) ) {
            if( auto except_expr = std::get_if<ExceptionExpressionInfo>( &expr_info ) ) {
                switch( except_expr->type ) {
                case ExceptionExpressionInfo::Type::Unexpected:
                    std::println("due to an unexpected exception");
                    break;
                case ExceptionExpressionInfo::Type::Missing:
                    std::println("due to a missing exception");
                    break;
                default:
                    assert( false );
                }
            }
            std::println("with expansion:");
            print( ColourIntent::ReconstructedExpression, "  {}", expr_info );

            if( auto const* match_expr = std::get_if<MatchExpressionInfo>(&expr_info) ) {
                if( assertion_info.passed() )
                    std::print(" - matched");
                else
                    std::print(" - failed to match");

                if( !match_expr->sub_expressions.empty() ) {
                    std::println( " because:");
                    for( auto const& sub_expr : match_expr->sub_expressions ) { // NOSONAR NOLINT (misc-typo)
                        if( sub_expr.result )
                            std::print("    ✅ ");
                        else
                            std::print("    ❌ ");
                        print( ColourIntent::ReconstructedExpression, "{} ", sub_expr.description );
                        if( sub_expr.result )
                            std::println("matched");
                        else
                            std::println("failed to match");
                    }
                }
            }
            std::println();
        }
        if( !assertion_info.variables.empty() ) {
            std::println("with captured variables:");
            for( auto const& var : assertion_info.variables )
                println( ColourIntent::SecondaryText, "  {} : {} = {}", var.name, var.type, var.value );
        }
        if( !assertion_info.message.empty() ) {
            std::println("with message:");
            println(ColourIntent::SecondaryText, "  {}", assertion_info.message);
        }
    }

    void ConsoleReporter::on_shrink_start() {
        std::println("Attempting to find a simpler counterexample by \"shrinking\"...");
        shrinking = true;
    }
    void ConsoleReporter::on_no_shrink_found( int shrinks ) {
        std::println("\nNo simpler counterexample found after {} shrinks", shrinks);
    }
    void ConsoleReporter::on_shrink_result( ResultType result, int shrinks_so_far ) {
        constexpr int shrink_print_width = 37;
        if( shrinks_so_far < shrink_print_width ) {
            if( result == ResultType::Passed )
                std::print("✅");
            else
                std::print("❌");
        }
        else if( shrinks_so_far == shrink_print_width )
            std::print("... ");
    }
    void ConsoleReporter::on_shrink_found( std::vector<std::string> const& values, int shrinks ) {
        std::println("\nFalsifiable after {} shrinks:", shrinks);
        if( values.size() > 1 ) {
            int i = 0;
            for (auto const& value : values) {
                std::println("  value {}: {}", i, value);
                ++i;
            }
            std::println("Final run with these values:");
        }
        else {
            std::println("  value: {}", values[0]);
            std::println("Final run with this value:");
        }
    }
    void ConsoleReporter::on_shrink_end() {
        shrinking = false;
    }

    void ConsoleReporter::on_test_run_start() { /* Do nothing, for now */ }

    void ConsoleReporter::on_test_run_end() {
        bool should_print_summary =
            print_summary == PrintSummary::Always
            || ( print_summary == PrintSummary::OnlyWhenTestsAreReported &&
                (  (report_on_passing( what_to_report_on ) && test_totals.passed() > 0 )
                || ( report_on_failing( what_to_report_on ) && test_totals.failed > 0 )
                || test_totals.total() == 0 ) );

        if( should_print_summary )
            print_totals_divider(test_totals);

        if ( test_totals.total() == 0 ) {
            println( ColourIntent::Warning, "No tests ran" );
            return;
        }
        if( !should_print_summary )
            return;

        if ( assertion_totals.total() > 0 && test_totals.all_passed() ) {
            println( ColourIntent::ResultSuccess, "All tests passed ({} assertion(s) in {} tests)",
                assertion_totals.total(), test_totals.total() );
            return;
        }

        auto print_summary_box = [](Counters const& counts, std::string const& label) { // NOSONAR NOLINT (misc-typo)
            std::print("{}: {}", label, counts.total() );
            if( counts.passed() > 0) {
                print( Colours::BoldGrey, " | " );
                print( ColourIntent::ResultSuccess, "{} passed", counts.passed() );
            }
            if( counts.failed_expectedly > 0) {
                print( Colours::BoldGrey, " | " );
                print( ColourIntent::Warning, "{} failed expectly", counts.failed_expectedly );
            }
            if( counts.failed > 0) {
                print( Colours::BoldGrey, " | " );
                print( ColourIntent::ResultError, "{} failed", counts.failed );
            }
            std::println();
        };
        print_summary_box(test_totals, "test cases");
        print_summary_box(assertion_totals, "assertions");
    }

} // namespace CatchKit
// Packed from catch23/src/generators.cpp
namespace CatchKit::Detail {

    namespace Charsets {
        std::string const lcase = "abcdefghijklmnopqrstuvwxyz"; // NOLINT (misc-typo)
        std::string const ucase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; // NOLINT (misc-typo)
        std::string const all_alpha = lcase + ucase;
        std::string const numbers = "01234567890";
        std::string const alphanumeric = all_alpha + numbers;
        std::string const word_chars = alphanumeric + " ";
        std::string const symbols = R"(!@£$%^&*()-=_+[]{};'\\:\"|,./<>?`~)";
        std::string const printable_ascii = word_chars + symbols;
    }


    auto values_of<std::string>::generate( RandomNumberGenerator& rng ) const -> std::string {
        auto len = rng.generate( min_len, max_len );
        std::string str;
        str.resize(len);
        for( std::size_t i = 0; i < len; ++i )
            str[i] = charset[rng.generate<std::size_t>( 0, charset.length()-1) ];
        return str;
    }

} // namespace CatchKit::Generators::Detail

// Packed from catch23/src/internal_execution_nodes.cpp
namespace CatchKit::Detail {

    auto ExecutionNode::get_current_node() const -> ExecutionNode* {
        assert(container);
        return container->current_node;
    }
    auto ExecutionNode::set_current_node(ExecutionNode* node) { // NOLINT
        assert(container);
        return container->current_node = node;
    }

    auto ExecutionNode::find_child( std::source_location loc_to_find ) const -> ExecutionNode* {
        for(auto const& child : children) {
            if( locations_are_equal(child->id.location, loc_to_find) )
                return child.get();
        }
        return nullptr;
    }

    auto ExecutionNode::add_child(NodeId const& id_to_add) -> ExecutionNode& {
        return add_child( std::make_unique<ExecutionNode>(id_to_add) );
    }

    void ExecutionNode::reset() {
        if( state != States::NotEntered ) {
            state = States::NotEntered;
            current_index = 0;
            move_first();
            reset_children();
        }
    }
    void ExecutionNode::reset_children() { // NOLINT NOSONAR
        for(auto const& child : children) {
            child->reset();
        }
    }

    void ExecutionNode::enter() {
        assert(state != States::Entered && state != States::Completed);
        state = States::Entered;
        set_current_node(this);
    }

    auto ExecutionNode::move_next() -> bool {
        return ++current_index == 1;
    }

    auto ExecutionNode::exit(bool early) -> States {
        using enum States;
        assert(state == Entered || state == EnteredButDoneForThisLevel);

        if(parent) {
            assert(parent->state == Entered || parent->state == EnteredButDoneForThisLevel);
            parent->state = EnteredButDoneForThisLevel;
        }
        bool all_children_are_complete = true;
        for(auto const& child : children) {
            if( child->state == Entered || child->state == EnteredButDoneForThisLevel )
                child->exit();
            if( child->state != Completed && child->state != NotEntered ) {
                state = HasIncompleteChildren;
            }
            if( child->state == ExitedEarly )
                child->state = Completed;

            if( child->state != Completed )
                all_children_are_complete = false;
        }
        if( get_current_node() == this ) {
            set_current_node(parent);
        }

        if( state == HasIncompleteChildren )
            return state;

        if( state == EnteredButDoneForThisLevel && !all_children_are_complete )
            return state;

        assert( state == Entered || state == EnteredButDoneForThisLevel );

        if( !move_next() ) {
            reset_children();
            return state = Incomplete;
        }

        reset_children();
        if( early )
            return state = ExitedEarly;

        return state = Completed;
    }

    auto ExecutionNodes::add_node(std::unique_ptr<ExecutionNode>&& child) -> ExecutionNode& {
        child->container = this;
        return current_node->add_child(std::move(child));
    }

    auto ExecutionNodes::add_node(NodeId const& id) -> ExecutionNode& {
        assert(find_node(id) == nullptr);
        auto& new_node = current_node->add_child(id);
        new_node.container = this;
        return new_node;
    }

    auto ExecutionNode::freeze() -> States {
        States prev_state = state;
        state = States::Frozen;
        return prev_state;
    }
    void ExecutionNode::unfreeze(States prev_state) {
        state = prev_state;
    }

} // namespace CatchKit::Detail

// Packed from catch23/src/internal_test.cpp
namespace CatchKit::Detail {

    Test::Test( TestFunction&& test_fun, TestInfo&& test_info )
    : test_fun(std::move(test_fun)), test_info(std::move(test_info))
    {}

    AutoReg::AutoReg(Test&& test) {
        register_test(std::move(test));
    }
}

// Packed from catch23/src/main.cpp
#ifdef CATCH23_IMPL_MIN_MAIN
CATCH23_MIN_MAIN()
#endif

// Packed from catch23/src/meta_test.cpp
namespace CatchKit {

    auto MetaTestResults::failures() const -> int {
        return std::ranges::fold_left( all_results, 0, [](int acc, auto const& result){ return acc + (result.failed() ? 1 : 0); });
    }
    auto MetaTestResults::expected_failures() const -> int {
        return std::ranges::fold_left( all_results, 0, [](int acc, auto const& result){ return acc + (result.failed_expectedly() ? 1 : 0); });
    }

    MetaTestRunner::MetaTestRunner( std::string name, std::source_location location )
    :   name(std::move(name)),
        location(location)
    {}

    auto MetaTestRunner::run( Detail::Test const& test ) && -> MetaTestResults {
        TestRunner runner( reporter );
        runner.run_test( test );
        return MetaTestResults{ std::move(reporter.results) };
    }

    auto MetaTestRunner::run_test_by_name( std::string const& name_to_find ) && -> MetaTestResults {
        auto const* test = get_test_registry().find_test_by_name( name_to_find );
        if( test == nullptr )
            throw std::domain_error( "No such test: " + name_to_find );
        return std::move(*this).run(*test);
    }

} // namespace CatchKit
// Packed from catch23/src/runner.cpp
namespace CatchKit::Detail {

    namespace {
        void invoke_test( Test const& test, TestResultHandler& test_handler ) {
            Checker checker{.result_handler=&test_handler };
            Checker old_checker = std::move(::checker);
            ::checker = std::move(checker);

            try {
                test.test_fun(checker);
            }
            catch( TestCancelled ) { /* allow to pass through */ } // NOSONAR NOLINT (misc-typo)
            catch( ... ) { // NOSONAR NOLINT (misc-typo)
                // We need a new context because the old one had string_views to outdated data
                // - we want to preserve the last known source location, though
                AssertionContext context{
                    .macro_name = "",
                    .original_expression = "* unknown line after the reported location *",
                    .message = {},
                    .location = test_handler.get_last_known_location() };
                test_handler.on_assertion_start( ResultDisposition::Continue, context );
                if( test_handler.on_assertion_result(ResultType::Failed) == ResultDetailNeeded::Yes ) {
                    test_handler.on_assertion_result_detail(
                        ExceptionExpressionInfo{
                            get_exception_message(std::current_exception()),
                            ExceptionExpressionInfo::Type::Unexpected },
                        {} );
                }
            }
            ::checker = std::move(old_checker);
        }
    }
    auto try_shrink( Test const& test, TestResultHandler& test_handler, ExecutionNode* leaf_node ) {

        std::vector<ShrinkableNode*> shrinkables; // NOLINT (misc-typo)
        auto node = leaf_node;
        for(; node->get_parent(); node = node->get_parent())
            if( auto shrinkable = node->get_shrinkable())
                shrinkables.push_back( shrinkable );

        if( shrinkables.empty() )
            return;

        test_handler.on_shrink_start();

        auto& root_node = *node;

        leaf_node->freeze();
        root_node.exit();
        std::vector<std::string> shrunk_values;
        shrunk_values.reserve( shrinkables.size() );
        for( auto& shrinkable : shrinkables ) {
            shrinkable->start_shrinking();
            while( shrinkable->shrink() ) {
                root_node.enter();

                invoke_test(test, test_handler);

                if(!test_handler.passed())
                    shrinkable->rebase_shrink(); // Resets on current failing number

                leaf_node->freeze();
                root_node.exit();
            }
            if( shrinkable->stop_shrinking() )
                shrunk_values.push_back( shrinkable->current_value_as_string() );
        }
        test_handler.on_shrink_found(shrunk_values);

        root_node.enter();
        invoke_test(test, test_handler);
        // don't do final exit as it will happen in caller
        test_handler.on_shrink_end();

    }

    void TestRunner::run_tests( TestRegistry const& tests ) {
        run_tests( tests.get_all_tests() );
    }

    void TestRunner::run_test( Test const& test ) {
        ExecutionNodes execution_nodes({test.test_info.name, test.test_info.location});
        auto& root_node = execution_nodes.get_root();
        result_handler.set_execution_nodes(&execution_nodes);

        do {
            result_handler.on_test_start(test.test_info);

            root_node.enter();
            assert(root_node.get_state() != ExecutionNode::States::Completed);

            invoke_test(test, result_handler);

            auto current_execution_node = execution_nodes.get_current_node();
            if( !result_handler.passed() )
                try_shrink(test, result_handler, current_execution_node);

            root_node.exit();

            result_handler.on_test_end(test.test_info);
        }
        while(root_node.get_state() != ExecutionNode::States::Completed);

        result_handler.set_execution_nodes(nullptr);
    }

} // namespace CatchKit::Detail
// Packed from catch23/src/sections.cpp
namespace CatchKit::Detail {

    SectionInfo::~SectionInfo() {
        if( entered )
            node.exit( std::uncaught_exceptions() > 0 );
    }

    auto try_enter_section(ExecutionNodes& nodes, std::string_view name, std::source_location location) -> SectionInfo {
        auto node = nodes.find_node(location);
        if( !node )
            node = &nodes.add_node({std::string(name), location});

        // Don't enter if we've already entered a previous peer node
        // or if this node has already been completed
        if( node->get_parent_state() == ExecutionNode::States::EnteredButDoneForThisLevel ||
            node->get_state() == ExecutionNode::States::Completed ) {
            return SectionInfo{ *node, false };
        }
        node->enter();
        return SectionInfo{ *node, true };
    }

} // namespace CatchKit::Detail

// Packed from catch23/src/test_info.cpp
namespace CatchKit {

    auto TestInfo::has_tag_type(Tag::Type tag_type) const -> bool {
        return std::ranges::any_of(tags, [tag_type](auto const& tag) { return tag.type == tag_type && !tag.ignored; });
    }
    auto TestInfo::should_fail() const -> bool {
        return has_tag_type(Tag::Type::should_fail);
    }
    auto TestInfo::may_fail() const -> bool {
        return has_tag_type(Tag::Type::may_fail);
    }
}
// Packed from catch23/src/test_registry.cpp
namespace CatchKit::Detail {

    namespace {
        auto& get_registered_tests_impl() {
            static std::vector<Test> all_tests; // NOSONAR NOLINT (misc-typo)
            return all_tests;
        }
        bool& is_initialised() {
            static bool initialised = false;
            return initialised;
        }
    }
    void register_test( Test&& test ) {
        assert(!is_initialised()); // We can only call this during startup
        get_registered_tests_impl().emplace_back(std::move(test));
    }

    auto get_test_registry() -> TestRegistry const& {
        static std::optional<TestRegistry> all_tests;
        if( !is_initialised() ) {
            all_tests = TestRegistry{ std::move(get_registered_tests_impl()) };
            is_initialised() = true;
        }
        return *all_tests;
    }

    TestRegistry::TestRegistry( std::vector<Test>&& tests )
    :   all_tests( std::move( tests ) )
    {
        if( tests_by_name.empty() ) {
            for(auto&& [i, test] : std::views::enumerate( all_tests ) ) {
                tests_by_name.try_emplace( test.test_info.name, i );
            }
        }

    }

    auto TestRegistry::find_test_by_name(std::string const& name) const -> Test const* {
        if( auto it = tests_by_name.find( name ); it != tests_by_name.end() )
            return &all_tests[it->second];
        return nullptr;
    }
    auto TestRegistry::find_tests_by_tag(std::string tag_name) const -> std::generator<Test const*> {
        for(auto const& test : all_tests) {
            for( auto const& tag : test.test_info.tags ) {
                if( tag.name == tag_name ) {
                    co_yield &test;
                }
            }
        }
    }

} // namespace CatchKit::Detail
// Packed from catch23/src/test_result_handler.cpp
namespace CatchKit::Detail {

    TestResultHandler::TestResultHandler(Reporter& reporter)
    :   ResultHandler(reporter.report_on_what()),
        reporter(reporter)
    {}

    void TestResultHandler::on_test_start( TestInfo const& test_info ) {
        current_test_info = &test_info;
        reporter.on_test_start(test_info);
    }
    void TestResultHandler::on_test_end( TestInfo const& test_info ) {
        reporter.on_test_end(test_info, assertions);
        assertions = Counters();
        current_test_info = nullptr;
    }

    void TestResultHandler::on_assertion_start( ResultDisposition result_disposition, AssertionContext const& context ) {
        current_context = context;
        this->current_result_disposition = result_disposition;
        reporter.on_assertion_start( context );
    }

    void TestResultHandler::on_shrink_start() {
        shrinking_mode = ShrinkingMode::Shrinking;
        reporter.on_shrink_start();
        shrink_count = 0;
    }
    void TestResultHandler::on_shrink_found( std::vector<std::string> const& values ) {
        if( values.empty() ) {
            reporter.on_no_shrink_found( shrink_count );
            shrinking_mode = ShrinkingMode::NotShrunk;
            return;
        }
        shrinking_mode = ShrinkingMode::Shrunk;
        reporter.on_shrink_found( values, shrink_count );
    }

    void TestResultHandler::on_shrink_end() {
        shrinking_mode = ShrinkingMode::Normal;
        reporter.on_shrink_end();
    }
    auto TestResultHandler::on_assertion_result( ResultType result ) -> ResultDetailNeeded {
        if( current_test_info->should_fail() )
            last_result = (result == ResultType::Passed) ? AdjustedResult::Failed : AdjustedResult::Passed;
        else if( current_test_info->may_fail() && result == ResultType::Failed )
            last_result = AdjustedResult::FailedExpectly;
        else
            last_result = (result == ResultType::Passed) ? AdjustedResult::Passed : AdjustedResult::Failed;

        if( shrinking_mode == ShrinkingMode::Shrinking ) {
            shrink_count++;
            reporter.on_shrink_result(result, shrink_count);
            return ResultDetailNeeded::No;
        }
        if( shrinking_mode == ShrinkingMode::NotShrunk )
            return ResultDetailNeeded::No;

        // If we completed a shrink then we get called one more time so we report the details.
        // In that case we don't want to contribute to the assertion stats as will have already done so
        // before we started shrinking
        if( shrinking_mode != ShrinkingMode::Shrunk ) {
            switch(last_result) {
            case AdjustedResult::Passed:
                assertions.passed_explicitly++;
                break;
            case AdjustedResult::Failed:
                assertions.failed++;
                break;
            case AdjustedResult::FailedExpectly:
                assertions.failed_expectedly++;
                break;
            default:
                std::unreachable();
            }
        }

        if( !current_test_info->has_tag_type( Tag::Type::always_report ) ) { // NOSONAR NOLINT (misc-typo)
            if( last_result == AdjustedResult::Failed ) {
                if( (report_on & ReportOn::FailingTests) != ReportOn::FailingTests )
                    return ResultDetailNeeded::No;
            }
            else {
                if( (report_on & ReportOn::PassingTests) != ReportOn::PassingTests )
                    return ResultDetailNeeded::No;
            }
        }

        return ResultDetailNeeded::Yes;
    }

    void TestResultHandler::on_assertion_result_detail( ExpressionInfo const& expression_info, std::string_view message ) {
        assert(current_test_info);
        assert(current_context);

        auto variables =
            variable_captures
            | std::views::transform([](VariableCaptureRef const* var) {
                    return CapturedVariable{ std::string(var->name), normalise_type_name(var->type), var->get_value() };
                })
            | std::ranges::to<std::vector>();

        reporter.on_assertion_end(*current_context,
            AssertionInfo{ last_result, expression_info, std::string(message), std::move(variables) } );
    }

    void TestResultHandler::on_assertion_end() {
        current_context.reset();
        if( !passed() && current_result_disposition == ResultDisposition::Abort ) {
            throw TestCancelled(); // NOLINT
        }
    }

    void TestResultHandler::add_variable_capture( VariableCaptureRef* capture ) {
        variable_captures.push_back(capture);
    }
    void TestResultHandler::remove_variable_capture( VariableCaptureRef* capture ) {
        std::erase(variable_captures, capture);
    }

    auto TestResultHandler::get_last_known_location() const -> std::source_location {
        assert( current_test_info );
        if( current_context )
            return current_context->location;
        return current_test_info->location;
    }

    auto get_execution_nodes_from_result_handler(ResultHandler& handler) -> ExecutionNodes& {
        assert(dynamic_cast<TestResultHandler*>(&handler) != nullptr);
        auto execution_nodes = static_cast<TestResultHandler&>(handler).get_execution_nodes(); // NOLINT
        assert(execution_nodes);
        return *execution_nodes;
    }

} // namespace CatchKit::Detail
#endif // CATCHKIT_IMPL

#endif // CATCH23_PACKED_H_INCLUDED
