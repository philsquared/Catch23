/*
 * Catch23
 * Single header - Generated: 2025-07-31 21:50:47.956530
 * ----------------------------------------------------------
 * This file has been generated by merging together multiple source files.
 * Please don't edit it directly.
 *
 * Distributed under the MIT license. See text reproduced, below:
 *
 * Copyright 2025 Phil Nash
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
 * associated documentation files (the “Software”), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE
 */
#ifndef CATCH23_PACKED_H_INCLUDED
#define CATCH23_PACKED_H_INCLUDED

// Packed header

// System includes (for headers):
#include <random>
#include <exception>
#include <vector>
#include <string>
#include <string_view>
#include <optional>
#include <print>
#include <format>
#include <utility>
#include <cmath>
#include <type_traits>
#include <source_location>
#include <algorithm>
#include <memory>
#include <functional>
#include <cassert>

// From header files:

// Packed from catchkit/include/catchkit/result_type.h
namespace CatchKit {

    enum class ResultType {
        Unknown,
        Pass,
        ExpressionFailed,
        MatchFailed,
        UnexpectedException,
        MissingException
    };

} // namespace CatchKit


// Packed from catchkit/include/catchkit/operators.h
namespace CatchKit::Detail {

    enum class Operators {
        None,
        Equals,
        NotEqualTo,
        GreaterThan,
        LessThan,
        GreaterThanOrEqual,
        LessThanOrEqual
    };

} // namespace CatchKit::Detail


// Packed from catchkit/include/catchkit/expression_info.h
namespace CatchKit::Detail {

    struct SubExpressionInfo {
        std::string description;
        bool result;
    };

    struct ExpressionInfo
    {
        std::string lhs;
        std::string rhs;

        Operators op;
        std::string_view op_str;

        std::vector<SubExpressionInfo> sub_expressions = {};
    };

} // namespace CatchKit::Detail

namespace CatchKit {

    using Detail::ExpressionInfo;

}

template<>
struct std::formatter<CatchKit::Detail::ExpressionInfo> {
    constexpr auto parse(std::format_parse_context& ctx) { return ctx.begin(); }
    std::format_context::iterator format(const CatchKit::Detail::ExpressionInfo& expr, std::format_context& ctx) const;
};


// Packed from catchkit/include/catchkit/report_on.h
namespace CatchKit {

    enum class ReportOn {
        FailuresOnly,
        AllResults
    };

} // namespace CatchKit


// Packed from catchkit/include/catchkit/result_handler.h
namespace CatchKit::Detail
{
    struct AssertionContext;
    struct VariableCapture;

    enum class ResultDisposition { Abort, Continue };

    struct ResultHandler {
        ReportOn report_on;

        explicit ResultHandler(ReportOn report_on) : report_on(report_on) {}
        virtual ~ResultHandler();

        virtual void on_assertion_start( ResultDisposition result_disposition, AssertionContext&& context ) = 0;
        virtual void on_assertion_result( ResultType result, std::optional<ExpressionInfo> const& expression_info, std::string_view message ) = 0;
        virtual void on_assertion_end() = 0;

        virtual void add_variable_capture(VariableCapture*) { /* do nothing by default */ };
        virtual void remove_variable_capture(VariableCapture*) { /* do nothing by default */ };

    };

} // namespace CatchKit::Detail

namespace CatchKit
{
    using Detail::ResultDisposition;
}


// Packed from catchkit/include/catchkit/assertion_context.h
namespace CatchKit::Detail {

    struct AssertionContext {
        std::string_view macro_name;
        std::string_view original_expression;
        std::string_view message  = {};
        std::source_location location = std::source_location::current();

        auto combine_messages(std::string_view additional_message) -> std::string;
    };

} // namespace CatchKit::Detail

namespace CatchKit {

    using Detail::AssertionContext;

} // namespace CatchKit


// Packed from catchkit/include/catchkit/assert_result_handler.h
namespace CatchKit::Detail {

    struct AssertResultHandler : ResultHandler {
        AssertionContext current_context;
        ResultType last_result = ResultType::Unknown;
        ResultDisposition result_disposition = ResultDisposition::Abort;

        AssertResultHandler() : ResultHandler(ReportOn::FailuresOnly) {}

        void on_assertion_start( ResultDisposition result_disposition, AssertionContext&& context ) override;
        void on_assertion_result( ResultType result, std::optional<ExpressionInfo> const& expression_info, std::string_view message ) override;
        void on_assertion_end() override;
    };

    void set_current_assertion_handler( AssertResultHandler& handler ); // impl in catchkit_checker.cpp

} // namespace CatchKit::Detail


// Packed from catchkit/include/catchkit/expr_ref.h
namespace CatchKit::Detail {

    struct Asserter;

    // Holds binary expression
    template<typename LhsT, typename RhsT, Operators Op>
    struct BinaryExprRef {
        LhsT& lhs;
        RhsT& rhs;
        Asserter* asserter = nullptr;
        std::string message = {};

        auto evaluate() -> ResultType;
        auto expand( ResultType result ) -> ExpressionInfo;

        ~BinaryExprRef();

        [[maybe_unused]] auto&& operator, ( std::string_view message ) noexcept {
            this->message = message;
            return *this;
        }

    };

    // Holds a unary expression - ie just evaluates to a single value
    // Also used for the LHS of a binary expression during decomposition
    template<typename T>
    struct UnaryExprRef {
        T& value;
        Asserter* asserter;
        std::string message = {};

        auto evaluate() -> ResultType;
        auto expand( ResultType result ) -> ExpressionInfo;

        ~UnaryExprRef();

        template<Operators Op, typename RhsT>
        auto make_binary_expr( RhsT&& rhs ) noexcept {
            return BinaryExprRef<T, std::remove_reference_t<RhsT>, Op>{ value, rhs, std::exchange(asserter, nullptr) };
        }

        template<typename RhsT>
        [[maybe_unused]] friend auto operator == ( UnaryExprRef lhs, RhsT&& rhs ) noexcept {
            static_assert( requires{ lhs.value == rhs; } );
            return lhs.template make_binary_expr<Operators::Equals>( std::forward<RhsT>( rhs ) );
        }
        template<typename RhsT>
        [[maybe_unused]] friend auto operator != ( UnaryExprRef lhs, RhsT&& rhs ) noexcept {
            static_assert( requires{ lhs.value != rhs; } );
            return lhs.template make_binary_expr<Operators::NotEqualTo>( std::forward<RhsT>( rhs ) );
        }
        template<typename RhsT>
        [[maybe_unused]] friend auto operator < ( UnaryExprRef lhs, RhsT&& rhs ) noexcept {
            static_assert( requires{ lhs.value < rhs; } );
            return lhs.template make_binary_expr<Operators::LessThan>( std::forward<RhsT>( rhs ) );
        }
        template<typename RhsT>
        [[maybe_unused]] friend auto operator > ( UnaryExprRef lhs, RhsT&& rhs ) noexcept {
            static_assert( requires{ lhs.value > rhs; } );
            return lhs.template make_binary_expr<Operators::GreaterThan>( std::forward<RhsT>( rhs ) );
        }
        template<typename RhsT>
        [[maybe_unused]] friend auto operator <= ( UnaryExprRef lhs, RhsT&& rhs ) noexcept {
            static_assert( requires{ lhs.value <= rhs; } );
            return lhs.template make_binary_expr<Operators::LessThanOrEqual>( std::forward<RhsT>( rhs ) );
        }
        template<typename RhsT>
        [[maybe_unused]] friend auto operator >= ( UnaryExprRef lhs, RhsT&& rhs ) noexcept {
            static_assert( requires{ lhs.value >= rhs; } );
            return lhs.template make_binary_expr<Operators::GreaterThanOrEqual>( std::forward<RhsT>( rhs ) );
        }

        [[maybe_unused]] auto&& operator, ( std::string_view message ) noexcept {
            this->message = message;
            return *this;
        }

    };


    struct MatchResult;

    template<typename ArgT, typename MatcherT>
    struct MatchExprRef {
        ArgT& arg;
        MatcherT const& matcher;
        Asserter* asserter = nullptr;
        std::string message = {};

        auto evaluate() -> MatchResult;
        auto expand( MatchResult const& result ) -> ExpressionInfo;

        ~MatchExprRef();
    };

    struct SubExpression {
        bool result;
        void const* matcher_address;
    };

    // Holds the result of a match
    struct MatchResult {
        bool result;
        void const* matcher_address = nullptr;
        std::vector<SubExpression> child_results; // TBD: only include this in composite matcher results?
        explicit(false) MatchResult(bool result, void const* matcher_address = nullptr) : result(result), matcher_address(matcher_address) {}
        explicit operator bool() const { return result; }

        auto set_address(void const* address) -> MatchResult& {
            assert(matcher_address == nullptr || matcher_address == address);
            matcher_address = address;
            return *this;
        }
        auto add_children_from(MatchResult const& other) -> MatchResult& {
            child_results.reserve( child_results.size() + other.child_results.size() );
            std::ranges::copy( other.child_results, std::back_inserter( child_results ) );
            return *this;
        }
        auto make_child_of(void const* new_matcher_address) -> MatchResult& {
            child_results.emplace_back( result, std::exchange( matcher_address, new_matcher_address ) );
            return *this;
        }
    };

} // namespace CatchKit::Detail


// Packed from catchkit/include/catchkit/internal_warnings.h
#if defined(__clang__)
#define CATCHKIT_WARNINGS_SUPPRESS_START                _Pragma( "clang diagnostic push" )
#define CATCHKIT_WARNINGS_SUPPRESS_END                  _Pragma( "clang diagnostic pop" )
#define CATCHKIT_WARNINGS_SUPPRESS_PARENTHESES          _Pragma( "clang diagnostic ignored \"-Wparentheses\"" )
#define CATCHKIT_WARNINGS_SUPPRESS_UNUSED_COMPARISON    _Pragma( "clang diagnostic ignored \"-Wunused-comparison\"" )
#define CATCHKIT_WARNINGS_SUPPRESS_ADDRESS              _Pragma( "clang diagnostic ignored \"-Waddress\"" )
#define CATCHKIT_WARNINGS_SUPPRESS_SIGN_MISMATCH        _Pragma( "clang diagnostic ignored \"-Wsign-compare\"" )
#define CATCHKIT_WARNINGS_SUPPRESS_UNUSED_PARAMETER     _Pragma( "clang diagnostic ignored \"-Wunused-parameter\"" )
#define CATCHKIT_WARNINGS_SUPPRESS_FLOAT_RANGE          _Pragma( "clang diagnostic ignored \"-Wliteral-range\"" )
#define CATCHKIT_WARNINGS_SUPPRESS_NULL_CONVERSION      _Pragma( "clang diagnostic ignored \"-Wnull-conversion\"" )

#elif defined(__GNUC__) && !defined(__ICC) && !defined(__CUDACC__) // GCC
#define CATCHKIT_WARNINGS_SUPPRESS_START                _Pragma( "GCC diagnostic push" )
#define CATCHKIT_WARNINGS_SUPPRESS_END                  _Pragma( "GCC diagnostic pop" )
#define CATCHKIT_WARNINGS_SUPPRESS_PARENTHESES          _Pragma( "GCC diagnostic ignored \"-Wparentheses\"" )
#define CATCHKIT_WARNINGS_SUPPRESS_UNUSED_COMPARISON
#define CATCHKIT_WARNINGS_SUPPRESS_ADDRESS              _Pragma( "GCC diagnostic ignored \"-Waddress\"" )
#define CATCHKIT_WARNINGS_SUPPRESS_SIGN_MISMATCH        _Pragma( "GCC diagnostic ignored \"-Wsign-compare\"" )
#define CATCHKIT_WARNINGS_SUPPRESS_UNUSED_PARAMETER     _Pragma( "GCC diagnostic ignored \"-Wunused-parameter\"" )
#define CATCHKIT_WARNINGS_SUPPRESS_FLOAT_RANGE
#define CATCHKIT_WARNINGS_SUPPRESS_NULL_CONVERSION

#elif define(_MSC_VER)
#define CATCHKIT_WARNINGS_SUPPRESS_START                __pragma( warning(push) )
#define CATCHKIT_WARNINGS_SUPPRESS_END                  __pragma( warning(pop) )
#define CATCHKIT_WARNINGS_SUPPRESS_PARENTHESES
#define CATCHKIT_WARNINGS_SUPPRESS_UNUSED_COMPARISON
#define CATCHKIT_WARNINGS_SUPPRESS_ADDRESS
#define CATCHKIT_WARNINGS_SUPPRESS_SIGN_MISMATCH        __pragma( warning( disable:4389 ) ) __pragma( warning( disable:4018 ) )
#define CATCHKIT_WARNINGS_SUPPRESS_UNUSED_PARAMETER
#define CATCHKIT_WARNINGS_SUPPRESS_FLOAT_RANGE
#define CATCHKIT_WARNINGS_SUPPRESS_NULL_CONVERSION

#else
// !TBD Other compilers
#define CATCHKIT_WARNINGS_SUPPRESS_START
#define CATCHKIT_WARNINGS_SUPPRESS_END
#define CATCHKIT_WARNINGS_SUPPRESS_PARENTHESES
#define CATCHKIT_WARNINGS_SUPPRESS_UNUSED_COMPARISON
#define CATCHKIT_WARNINGS_SUPPRESS_ADDRESS
#define CATCHKIT_WARNINGS_SUPPRESS_UNUSED_PARAMETER
#define CATCHKIT_WARNINGS_SUPPRESS_FLOAT_RANGE
#define CATCHKIT_WARNINGS_SUPPRESS_NULL_CONVERSION

#endif


// Packed from catchkit/include/catchkit/operator_to_string.h
namespace CatchKit::Detail {

    // String conversions for operator enum
    template<Operators op>
    [[nodiscard]] consteval auto operator_to_string() noexcept
    {
        using enum Operators;
        if constexpr( op == Equals )                    return "==";
        else if constexpr( op == NotEqualTo )           return "!=" ;
        else if constexpr( op == GreaterThan )          return ">";
        else if constexpr( op == LessThan )             return "<";
        else if constexpr( op == GreaterThanOrEqual )   return ">=";
        else if constexpr( op == LessThanOrEqual )      return "<=";
        else {
            // Note that while None is a valid enum value, we should never use it on a path that leads here
            static_assert( false, "Unrecognised operator" );
        }
    }

} // namespace CatchKit::Detail


// Packed from catchkit/include/catchkit/exceptions.h
namespace CatchKit::Detail {

    extern std::string unknown_exception_message;

    [[nodiscard]] auto get_exception_message( std::exception_ptr const& ex ) -> std::string;

    [[nodiscard]] auto get_exception_message( std::exception const& ex ) -> std::string;
    [[nodiscard]] auto get_exception_message( std::string const& str ) -> std::string;

    [[nodiscard]] inline auto get_exception_message(...) -> std::string {
        return unknown_exception_message;
    }

} // namespace CatchKit::Detail


// Packed from catchkit/include/catchkit/stringify.h
#define CATCHKIT_FALLBACK_TO_FORMAT_STRING_CONVERSIONS
// #define CATCHKIT_FALLBACK_TO_OSTREAM_STRING_CONVERSIONS

#ifdef CATCHKIT_FALLBACK_TO_FORMAT_STRING_CONVERSIONS
#include <format>
#endif
#ifdef CATCHKIT_FALLBACK_TO_OSTREAM_STRING_CONVERSIONS
#include <sstream>
#endif

namespace CatchKit {

    namespace Detail {
        auto pointer_to_string(void const* p) -> std::string;
        void ignore( auto&& ) noexcept {}

        auto parse_templated_name( std::string const& templated_name, std::string_view function_name ) -> std::string_view;
        auto parse_templated_name( std::string const& templated_name, std::source_location location = std::source_location::current() ) -> std::string_view;
        auto parse_enum_name_from_function(std::string_view function_name, bool fully_qualified = false) -> std::string_view;
        auto unknown_enum_to_string(size_t enum_value) -> std::string;

        constexpr size_t enum_probe_start = 0;
        constexpr size_t enum_probe_end = 16;

        template<typename E, E candidate=static_cast<E>(enum_probe_start), size_t max_probe=enum_probe_end>
        struct enum_value_string {
            static auto find(E e) -> std::string_view {
                if( e == candidate )
                    return parse_enum_name_from_function(std::source_location::current().function_name());
                if constexpr(static_cast<size_t>( candidate) < max_probe )
                    return enum_value_string<E, static_cast<E>(static_cast<size_t>(candidate)+1)>::find(e);
                return {};
            }
        };

        template<typename E>
        auto enum_to_string(E e) -> std::string {
            if( auto val = enum_value_string<E>::find(e); !val.empty() )
                return std::string(val);
            return unknown_enum_to_string(static_cast<size_t>(e));
        }

    }

    #ifdef FALLBACK_TO_OSTREAM_STRING_CONVERSIONS
    template <typename T>
    concept Streamable = requires( std::ostream os, T value ) {
        { os << value };
    };
    #endif

    template<typename T>
    [[nodiscard]] auto constexpr stringify(T const& value );

    template<typename T>
    struct Stringifier {
        [[nodiscard]] static auto stringify( T const& value ) -> std::string {

            #ifdef FALLBACK_TO_FORMAT_STRING_CONVERSIONS
            if constexpr( std::formattable<T, char> ) {
                return std::format("{}", value);
            }
            #endif

            #ifdef FALLBACK_TO_OSTREAM_STRING_CONVERSIONS
            if constexpr ( Streamable<T> ) {
                std::ostringstream oss; // !TBD: use an ostringstream pool?
                oss << value;
                return oss.str();
            }
            #endif

            #if !defined(FALLBACK_TO_OSTREAM_STRING_CONVERSIONS) && !defined(FALLBACK_TO_FORMAT_STRING_CONVERSIONS)
            Detail::ignore( value );
            #endif

            return "{?}";
        }
    };

    template<typename T>
    requires requires{ !std::same_as<std::decay_t<T>, char>; }
    struct Stringifier<T*> {
        [[nodiscard]] static constexpr auto stringify( T* value ) -> std::string {
            return value ? Detail::pointer_to_string( value ) : std::string("nullptr");
        }
    };

    template<typename T, typename A>
    struct Stringifier<std::vector<T, A>> {
        [[nodiscard]] static constexpr auto stringify( std::vector<T, A> const& values ) -> std::string {
            std::string s = "[";
            bool first = true;
            for(auto&& val : values) {
                if( !first )
                    s += ", ";
                else
                    first = false;
                s += CatchKit::stringify( val );
            }
            s += "]";
            return s;
        }
    };

    // !TBD: more conversions of built-ins, including containers
    // - also wait for std::format for ranges to match with that

    // Don't specialise this
    template<typename T>
    [[nodiscard]] auto constexpr stringify(T const& value ) {
        if constexpr( std::same_as<T, bool> )
            return value ? "true" : "false";
        else if constexpr( std::is_enum_v<T> )
            return Detail::enum_to_string( value );
        else if constexpr( std::floating_point<T> || std::integral<T> )
            return std::to_string( value );
        else if constexpr( std::is_null_pointer_v<T> )
            return "nullptr";
        else if constexpr( std::is_convertible_v<T, std::string> )
            return std::format("\"{}\"", value);
        else
            return Stringifier<T>::stringify( value );
    }

} // namespace CatchKit


// Packed from catchkit/include/catchkit/variable_capture.h
namespace CatchKit::Detail
{
    struct Checker;
    struct ResultHandler;

    struct VariableCapture {
        std::string_view name;
        std::string_view type;
        ResultHandler& result_handler;

        [[nodiscard]] virtual auto get_value() const -> std::string = 0;

    protected:
        VariableCapture(std::string_view name, std::string_view type, Checker& checker);
        ~VariableCapture(); // not virtual because we never destroy polymorphically
    };

    template<typename T>
    struct TypedVariableCapture : VariableCapture {
        T const& value;

        [[nodiscard]] auto get_value() const -> std::string override { return stringify( value ); }

        TypedVariableCapture(T const& value, std::string_view name, Checker& checker)
        :   VariableCapture( name, parse_templated_name("T"), checker ),
            value(value)
        {}
    };

} // namespace CatchKit::Detail

#define CATCHKIT_INTERNAL_DECLARE_VAR_X(suffix, var) CatchKit::Detail::TypedVariableCapture CATCHKIT_INTERNAL_UNIQUE_NAME(var_capture##suffix)(var, #var, check)

#define CATCHKIT_INTERNAL_DECLARE_VARS_1(a) CATCHKIT_INTERNAL_DECLARE_VAR_X(_1, a)
#define CATCHKIT_INTERNAL_DECLARE_VARS_2(a, b) CATCHKIT_INTERNAL_DECLARE_VAR_X(_1, a); CATCHKIT_INTERNAL_DECLARE_VAR_X(_2, b)
#define CATCHKIT_INTERNAL_DECLARE_VARS_3(a, b, c) CATCHKIT_INTERNAL_DECLARE_VAR_X(_1, a); CATCHKIT_INTERNAL_DECLARE_VAR_X(_2, b); CATCHKIT_INTERNAL_DECLARE_VAR_X(_3, c)
#define CATCHKIT_INTERNAL_DECLARE_VARS_4(a, b, c, d) CATCHKIT_INTERNAL_DECLARE_VAR_X(_1, a); CATCHKIT_INTERNAL_DECLARE_VAR_X(_2, b); CATCHKIT_INTERNAL_DECLARE_VAR_X(_3, c); CATCHKIT_INTERNAL_DECLARE_VAR_X(_4, d)

#define DECLARE_VARS_ERROR(...) \
    static_assert(false, \
        "CAPTURE ERROR: Too many variable names provided! " \
        "This macro supports a maximum of 4 variables. " \
        "Consider breaking into multiple CAPTURE calls.")

#define CATCHKIT_INTERNAL_GET_6TH_ARG(arg1, arg2, arg3, arg4, arg5, arg6, ...) arg6
#define CATCHKIT_INTERNAL_DECLARE_VARS_CHOOSER(...) CATCHKIT_INTERNAL_GET_6TH_ARG(__VA_ARGS__, DECLARE_VARS_ERROR, CATCHKIT_INTERNAL_DECLARE_VARS_4, CATCHKIT_INTERNAL_DECLARE_VARS_3, CATCHKIT_INTERNAL_DECLARE_VARS_2, CATCHKIT_INTERNAL_DECLARE_VARS_1)

#define CATCHKIT_INTERNAL_VAR(...) CATCHKIT_INTERNAL_DECLARE_VARS_CHOOSER(__VA_ARGS__)(__VA_ARGS__)
#define CAPTURE(...) CATCHKIT_INTERNAL_VAR(__VA_ARGS__)


// Packed from catchkit/include/catchkit/checker.h
namespace CatchKit::Detail
{
    struct Asserter;

    struct Checker {
        ResultHandler& result_handler;
        ResultDisposition result_disposition;
        bool should_decompose = true;

        auto operator()(std::string_view message = {}, std::source_location assertion_location = std::source_location::current()) -> Asserter;
        auto operator()(AssertionContext&& context) -> Asserter;
    };

    struct Asserter {
        Checker& checker;

        ~Asserter() noexcept(false) {
            checker.result_handler.on_assertion_end(); // This may throw to cancel the test
        }
        void handle_unexpected_exceptions(std::invocable<Asserter&> auto const& expr_call) {
            try {
                expr_call(*this);
            }
            catch(...) {
                checker.result_handler.on_assertion_result( ResultType::UnexpectedException, {}, get_exception_message(std::current_exception()) );
            }
        }

        template<typename T>
        void simple_assert(auto const&, T&&) noexcept {
            static_assert(std::is_convertible_v<T, std::string_view>, "Only matchers or strings can follow the comma operator");
        }
        void simple_assert(std::nullptr_t, std::string_view message = {}) noexcept {
            simple_assert(false, message);
        }
        void simple_assert(auto const& result, std::string_view message = {}) noexcept {
            bool is_failure = !result;
            if( checker.result_handler.report_on == ReportOn::AllResults || is_failure ) {}
                checker.result_handler.on_assertion_result(is_failure ? ResultType::ExpressionFailed : ResultType::Pass, {}, message);
        }
        void accept_expr(auto& expr) noexcept; // Implemented after the definitions of the Expr Ref types

        template<typename ArgT, typename MatcherT> // !TBD Matcher concept
        constexpr auto that( ArgT&& arg, MatcherT const& matcher ) noexcept {
            // !TBD: Should we use only this path, or keep the decomp operator path, too?
            return MatchExprRef{ arg, matcher, this };
        }

        // To kick off an expression decomposition
        template<typename LhsT>
        [[maybe_unused]] friend constexpr auto operator << ( Asserter& asserter, LhsT&& lhs ) noexcept {
            return UnaryExprRef{ lhs, &asserter };
        }
        template<typename LhsT>
        [[maybe_unused]] friend constexpr auto operator << ( Asserter&& asserter, LhsT&& lhs ) noexcept {
            return UnaryExprRef{ lhs, &asserter };
        }
    };

    // --------------

    template<typename T>
    UnaryExprRef<T>::~UnaryExprRef() {
        if( asserter )
            asserter->accept_expr(*this);
    }

    template<typename T>
    auto UnaryExprRef<T>::evaluate() -> ResultType {
        if constexpr( requires (T v){ { !v } -> std::same_as<bool>; }) {
            CATCHKIT_WARNINGS_SUPPRESS_START
            CATCHKIT_WARNINGS_SUPPRESS_ADDRESS
            CATCHKIT_WARNINGS_SUPPRESS_NULL_CONVERSION
            return !value ? ResultType::ExpressionFailed : ResultType::Pass;
            CATCHKIT_WARNINGS_SUPPRESS_END
        }
        else if constexpr( std::is_null_pointer_v<T> ) {
            // Special case for GCC
            return ResultType::ExpressionFailed;
        }
        else {
            // Have to do this at runtime because we can get here from the destructor of a UnaryExpr,
            // even if it doesn't happen at runtime because it's actually a binary expresion
            throw std::logic_error("Attempt to use a value that cannot convert to bool in boolean context");
        }
    }
    template<typename T>
    auto UnaryExprRef<T>::expand(ResultType) -> ExpressionInfo {
        return ExpressionInfo{ {std::string(stringify(value))}, {}, Operators::None, {} };
    }

    template<typename LhsT, typename RhsT, Operators Op>
    BinaryExprRef<LhsT, RhsT, Op>::~BinaryExprRef() {
        if( asserter )
            asserter->accept_expr(*this);
    }

    CATCHKIT_WARNINGS_SUPPRESS_START CATCHKIT_WARNINGS_SUPPRESS_SIGN_MISMATCH
    template<typename LhsT, typename RhsT, Operators Op>
    auto eval_expr(BinaryExprRef<LhsT, RhsT, Op>& expr) {
        using enum Operators;
        if constexpr( Op == Equals )                    return expr.lhs == expr.rhs;
        else if constexpr( Op == NotEqualTo )           return expr.lhs != expr.rhs;
        else if constexpr( Op == GreaterThan )          return expr.lhs >  expr.rhs;
        else if constexpr( Op == LessThan )             return expr.lhs <  expr.rhs;
        else if constexpr( Op == GreaterThanOrEqual )   return expr.lhs >= expr.rhs;
        else if constexpr( Op == LessThanOrEqual )      return expr.lhs <= expr.rhs;
        else {
            // Note that while None is a valid enum value, we should never use it on a path that leads here
            static_assert( false, "Operator not implemented" );
        }
        std::unreachable();
    }
    CATCHKIT_WARNINGS_SUPPRESS_END

    template<typename LhsT, typename RhsT, Operators Op>
    auto BinaryExprRef<LhsT, RhsT, Op>::evaluate() -> ResultType {
        return static_cast<bool>( eval_expr(*this) ) ? ResultType::Pass : ResultType::ExpressionFailed;
    }
    template<typename LhsT, typename RhsT, Operators Op>
    auto BinaryExprRef<LhsT, RhsT, Op>::expand(ResultType) -> ExpressionInfo {
        return ExpressionInfo{
            std::string( stringify(lhs) ),
            std::string( stringify(rhs) ),
            Op,
            operator_to_string<Op>() };
    }

    template<typename ArgT, typename MatcherT>
    MatchExprRef<ArgT, MatcherT>::~MatchExprRef() {
        if( asserter )
            asserter->accept_expr(*this);
    }

    inline auto to_result_type( MatchResult const& result ) -> ResultType { return result ? ResultType::Pass : ResultType::MatchFailed; }

    // -------

    inline auto to_result_type( ResultType result ) -> ResultType { return result; }

    void Asserter::accept_expr( auto& expr ) noexcept {
        auto raw_result = expr.evaluate();
        auto result = to_result_type( raw_result );
        if( checker.result_handler.report_on == ReportOn::AllResults || result != ResultType::Pass ) {
            checker.result_handler.on_assertion_result( result, expr.expand( raw_result ), expr.message );
        }
        else {
            checker.result_handler.on_assertion_result( result, {}, expr.message );
        }
    }

} // namespace CatchKit::Detail

namespace CatchKit
{
    using Detail::Checker;

} //namespace CatchKit

// These global instances are used if not using the ones passed in to a function locally
extern constinit CatchKit::Checker check, require;


#define CATCHKIT_ASSERT_INTERNAL(macro_name, checker, ...) \
if(checker.should_decompose) { \
    CATCHKIT_WARNINGS_SUPPRESS_START CATCHKIT_WARNINGS_SUPPRESS_UNUSED_COMPARISON \
    checker(CatchKit::AssertionContext(macro_name, #__VA_ARGS__)).handle_unexpected_exceptions([&](CatchKit::Detail::Asserter& asserter){ asserter << __VA_ARGS__; }); \
    CATCHKIT_WARNINGS_SUPPRESS_END \
} else checker(CatchKit::AssertionContext(macro_name, #__VA_ARGS__)).simple_assert(__VA_ARGS__)


#define CATCHKIT_ASSERT_THAT_INTERNAL(macro_name, checker, arg, match_expr) \
do { using namespace CatchKit::Matchers; \
    checker(CatchKit::AssertionContext(macro_name, #arg ", " #match_expr)).that( [&]{ return arg; }, match_expr ); \
} while( false )


#define CHECK(...) CATCHKIT_ASSERT_INTERNAL( "CHECK", check, __VA_ARGS__ )
#define REQUIRE(...) CATCHKIT_ASSERT_INTERNAL( "REQUIRE", require, __VA_ARGS__ )

#define CHECK_THAT( arg, matcher ) CATCHKIT_ASSERT_THAT_INTERNAL( "CHECK_THAT", check, arg, matcher )
#define REQUIRE_THAT( arg, matcher ) CATCHKIT_ASSERT_THAT_INTERNAL( "REQUIRE_THAT", require, arg, matcher )

#define REQUIRE_STATIC(...) static_assert(__VA_ARGS__)

// !TBD: These should have a dedicated internal macro (in Catch2 it was INTERNAL_CATCH_MSG)
#define PASS(...) CATCHKIT_ASSERT_INTERNAL( "PASS", check, true __VA_OPT__(,) __VA_ARGS__ )
#define FAIL(...) CATCHKIT_ASSERT_INTERNAL( "FAIL", require, false __VA_OPT__(,) __VA_ARGS__ )



// Packed from catchkit/include/catchkit/internal_matchers.h
namespace CatchKit {

    using Detail::MatchResult;

    namespace Detail {

        struct CouldBeAnything {
            template <typename T> explicit(false) operator T() const;
        };

        struct AlwaysMatcher {
            auto match(auto&&) const -> MatchResult { return true; }
            auto lazy_match(auto&&) const -> MatchResult  { return true; }
        };

        template<typename M, typename T=CouldBeAnything>
        concept IsEagerMatcher = requires(M m, T something) {
            { m.match(something) } -> std::same_as<MatchResult>;
        };

        template<typename M>
        concept IsLazyMatcher = requires(M m) {
            { m.lazy_match([]{}) } -> std::same_as<MatchResult>;
        };

        template<typename M>
        concept IsEagerBindableMatcher = requires(M m, CouldBeAnything something, AlwaysMatcher matcher) {
            { m.bound_match(something, matcher) } -> std::same_as<MatchResult>;
        };

        template<typename M>
        concept IsLazyBindableMatcher = requires(M m, AlwaysMatcher matcher) {
            { m.lazy_bound_match([]{}, matcher) } -> std::same_as<MatchResult>;
        };

        template<typename M>
        concept IsMatcher = IsEagerMatcher<M> || IsLazyMatcher<M>;

        template<typename M>
        concept MatcherHasDescribeMethod = requires(M const m) {
            { m.describe() } -> std::convertible_to<std::string>;
        };

        template<typename ArgT, typename MatcherT>
        auto invoke_matcher( MatcherT& matcher, ArgT&& arg ) -> MatchResult {
            if constexpr( IsLazyMatcher<MatcherT> ) {
                if constexpr( std::invocable<ArgT> )
                // static_assert( std::invocable<ArgT>, "Lazy matchers must be matched against lambdas" );
                    return matcher.lazy_match( arg ).set_address(&matcher);
                else if constexpr( IsEagerMatcher<MatcherT> )
                    return matcher.match( arg ).set_address( &matcher );
                else
                    static_assert( false, "Lazy matchers must be matched against lambdas" );
            }
            else if constexpr( IsEagerMatcher<MatcherT> ) {
                if constexpr( std::invocable<ArgT> )
                    return matcher.match( arg() ).set_address(&matcher);
                else
                    return matcher.match( arg ).set_address( &matcher );
            }
            else {
                static_assert( false, "RHS of match statement is not a matcher" );
            }
        }


        // The result of a && expression
        template<typename M1, typename M2>
        struct AndMatcher {
            M1& matcher1;
            M2& matcher2;

            auto match( auto const& value ) const -> MatchResult {
                auto result1 = invoke_matcher( matcher1, value ).make_child_of(this);
                if( !result1 )
                    return result1; // Short circuit
                return invoke_matcher( matcher2, value )
                    .make_child_of(this) // Create new matcher for this level
                    .add_children_from(result1); // add in the other result

            }
            [[nodiscard]] auto describe() const {
                return std::format("({} && {})", matcher1.describe(), matcher2.describe());
            }
        };

        // The result of a || expression
        template<typename M1, typename M2>
        struct OrMatcher {
            using composite_matcher = void;

            M1& matcher1;
            M2& matcher2;

            auto match( auto const& value ) const -> MatchResult {
                auto result1 = invoke_matcher(matcher1, value).make_child_of(this);
                if( result1 )
                    return result1; // Short circuit
                return invoke_matcher( matcher2,  value )
                    .make_child_of(this) // Create new matcher for this level
                    .add_children_from(result1); // add in the other result
            }
            [[nodiscard]] auto describe() const {
                return std::format("({} || {})", matcher1.describe(), matcher2.describe());
            }
        };

        // The result of a ! expression
        template<typename M>
        struct NotMatcher {
            M& base_matcher;

            auto match( auto const& value ) const -> MatchResult {
                return match_common( value );
            }
            // !TBD: only include lazy_match if the base matcher is lazy
            auto lazy_match( auto const& value ) const -> MatchResult {
                return match_common( value );
            }
            auto match_common( auto const& value ) const -> MatchResult {
                auto result = invoke_matcher(base_matcher, value).make_child_of(this);
                result.result = !result.result;
                return result;

            }
            [[nodiscard]] auto describe() const {
                return std::format("!({})", base_matcher.describe());
            }
        };

        template<typename M2>
        auto operator && (IsMatcher auto&& m1, M2&& m2) {
            static_assert(IsMatcher<M2>, "Operand to && is not a matcher");
            return AndMatcher(m1, m2);
        }

        template<typename M2>
        auto operator || (IsMatcher auto&& m1, M2&& m2) {
            static_assert(IsMatcher<M2>, "Operand to || is not a matcher");
            return OrMatcher( m1, m2 );
        }

        auto operator ! (IsMatcher auto&& m) {
            return NotMatcher(m);
        }

        // Matchers may be monadically bound with the >>= operator.
        // If so, the left operand must implement bound_match() or lazy_bound_match()
        template<typename M1, typename M2>
        struct BoundMatchers {
            M1 matcher1;
            M2 matcher2;

            template<typename ArgT>
            auto lazy_match( ArgT const& arg ) const -> MatchResult {
                if constexpr ( IsLazyBindableMatcher<M1> ) {
                    static_assert( std::invocable<ArgT>, "Lazy matchers must be matched against lambdas" );
                    return matcher1.lazy_bound_match(arg, matcher2)
                        .set_address(&matcher1)
                        .make_child_of(this);
                }
                else
                    return match(arg);
            }

            template<typename ArgT>
            auto match( ArgT const& arg ) const -> MatchResult {
                static_assert( IsEagerBindableMatcher<M1>, "The LHS of >>= must be a bindable matcher" );
                if constexpr( std::invocable<ArgT> )
                    return matcher1.bound_match(arg(), matcher2)
                        .set_address(&matcher1)
                        .make_child_of(this);
                else
                    return matcher1.bound_match(arg, matcher2)
                        .set_address(&matcher1)
                        .make_child_of(this);
            }

            [[nodiscard]] auto describe() const -> std::string {
                return std::format("({} >>= {})", matcher1.describe(), matcher2.describe());
            }
        };

        template<IsMatcher M1, typename M2>
        auto operator >>= ( M1&& m1, M2&& m2 ) {
            static_assert(IsMatcher<M2>, "Operand to >>= is not a matcher");
            return BoundMatchers{std::forward<M1>(m1), std::forward<M2>(m2)};
        }


        template<typename ArgT, IsMatcher MatcherT>
        [[maybe_unused]] constexpr auto operator, ( UnaryExprRef<ArgT>&& arg, MatcherT const& matcher ) noexcept {
            static_assert( MatcherHasDescribeMethod<MatcherT>, "Matcher is missing describe method" );
            return MatchExprRef{ arg.value, matcher, std::exchange(arg.asserter, nullptr) };
        }

        template<typename ArgT, typename MatcherT>
        [[maybe_unused]] constexpr auto operator, ( MatchExprRef<ArgT, MatcherT>&& matcher_ref, std::string_view message ) noexcept {
            matcher_ref.message = message;
            return matcher_ref;
        }

        template<typename M>
        concept IsBinaryCompositeMatcher = requires(M const m) {
            { m.matcher1 } -> IsMatcher;
            { m.matcher2 } -> IsMatcher;
        };

        template<typename M>
        concept IsUnaryCompositeMatcher = requires(M const m) {
            { m.base_matcher } -> IsMatcher;
        };

        template<typename M>
        concept IsCompositeMatcher = IsBinaryCompositeMatcher<M> || IsUnaryCompositeMatcher<M>;

        void add_subexpressions( std::vector<SubExpressionInfo>& sub_expressions, MatchResult const& results, void const* matcher_address, std::string const& description );

        template<typename M>
        auto collect_subexpressions(M const& matcher, std::vector<SubExpressionInfo>& sub_expressions, MatchResult const& results) {
            if constexpr( IsBinaryCompositeMatcher<M> ) {
                collect_subexpressions(matcher.matcher1, sub_expressions, results);
                collect_subexpressions(matcher.matcher2, sub_expressions, results);
            }
            else if constexpr( IsUnaryCompositeMatcher<M> ) {
                collect_subexpressions(matcher.base_matcher, sub_expressions, results);
            }
            else {
                add_subexpressions( sub_expressions, results, &matcher, matcher.describe() );
            }
        }

        template<typename ArgT, typename MatcherT>
        auto MatchExprRef<ArgT, MatcherT>::evaluate() -> MatchResult {
            return invoke_matcher( matcher, arg );
        }

        template<typename ArgT, typename MatcherT>
        auto MatchExprRef<ArgT, MatcherT>::expand( MatchResult const& result ) -> ExpressionInfo {
            std::vector<SubExpressionInfo> sub_expressions;
            if constexpr ( IsCompositeMatcher<MatcherT>) {
                collect_subexpressions(matcher, sub_expressions, result);
            }
            std::string expanded = matcher.describe() + (result ? " matched" : " failed to match" );
            return ExpressionInfo{ expanded, stringify(arg), Operators::None, {}, std::move(sub_expressions) };
        }

    } // namespace Detail

    namespace Matchers {

        using Detail::operator &&;
        using Detail::operator ||;
        using Detail::operator !;
        using Detail::operator >>=;

    } // namespace Matchers

} // namespace CatchKit


// Packed from catchkit/include/catchkit/matchers.h
namespace CatchKit {

    namespace GenericMatchers {
        template<typename T>
        struct Equals {
            T& match_value;

            [[nodiscard]] constexpr auto match(std::remove_const_t<T>& value) const -> MatchResult {
                return value == match_value;
            }
            [[nodiscard]] constexpr auto match(T const& value) const -> MatchResult {
                return value == match_value;
            }
            [[nodiscard]] auto describe() const {
                return std::format("equals( {} )", stringify(match_value));
            }
        };

        template<typename PredicateT>
        struct MatchesPredicate {
            PredicateT pred;
            std::string description;

            explicit MatchesPredicate( PredicateT&& pred, std::string description )
            : pred( std::move(pred) ), description( std::move(description) ) {}

            auto match( auto const& arg ) const -> MatchResult {
                return pred(arg);
            }
            auto describe() const -> std::string {
                return description;
            }
        };
    }

    namespace StringMatchers {

        struct CaseSensitive {
            static bool equal(std::string_view str1, std::string_view str2);
            static bool find(std::string_view str, std::string_view substr);
        };
        struct CaseInsensitive {
            static bool equal(std::string_view str1, std::string_view str2);
            static bool find(std::string_view str, std::string_view substr);
        };

        template<typename CasePolicy=CaseSensitive>
        struct StartsWith {
            std::string_view match_str;

            [[nodiscard]] auto match(std::string_view str) const -> MatchResult {
                if( match_str.size() > str.size() )
                    return false;
                return CasePolicy::equal(str.substr(0, match_str.size()), match_str);
            }
            [[nodiscard]] auto describe() const {
                return std::format("starts_with(\"{}\")", match_str);
            }
        };
        template<typename CasePolicy=CaseSensitive>
        struct EndsWith {
            std::string_view match_str;

            [[nodiscard]] auto match(std::string_view str) const -> MatchResult {
                if( match_str.size() > str.size() )
                    return false;
                return CasePolicy::equal(str.substr(str.size()-match_str.size()), match_str);
            }
            [[nodiscard]] auto describe() const {
                return std::format("ends_with(\"{}\")", match_str);
            }
        };
        template<typename CasePolicy=CaseSensitive>
        struct Contains {
            std::string_view match_str;
            [[nodiscard]] auto match(std::string_view str) const -> MatchResult {
                return CasePolicy::find(str, match_str);
            }
            [[nodiscard]] auto describe() const {
                return std::format("contains(\"{}\")", match_str);
            }
        };
        template<typename CasePolicy=CaseSensitive>
        struct Equals {
            std::string_view match_str;

            [[nodiscard]] auto match(std::string_view str) const -> MatchResult {
                return CasePolicy::equal(str, match_str);
            }
            [[nodiscard]] auto describe() const {
                return std::format("equals(\"{}\")", match_str);
            }
        };

    } // namespace StringMatchers

    namespace ExceptionMatchers {

        struct HasMessage {
            std::optional<std::string> what;

            [[nodiscard]] auto match(auto const& ex) const -> MatchResult {
                return what ? Detail::get_exception_message(ex) == *what : true;
            }
            template<typename BoundMatcherT>
            [[nodiscard]] auto bound_match(auto const& ex, BoundMatcherT const& bound_matcher ) const -> MatchResult {
                static_assert(Detail::IsEagerMatcher<BoundMatcherT>);

                std::string message = Detail::get_exception_message(ex);
                if( what && message != *what )
                    return false;

                return bound_matcher.match(message)
                    .set_address(&bound_matcher)
                    .make_child_of(this);
            }

            [[nodiscard]] auto describe() const -> std::string {
                if( what )
                    return std::format("has_message(\"{}\")", *what);
                else
                    return std::format("has_message()");
            }
        };

        template<typename E=void>
        struct Throws {
            template<Detail::IsEagerMatcher MessageMatcher>
            auto constexpr with_message_that( MessageMatcher const& message_matcher ) {
                using Detail::operator >>=;
                return *this >>= HasMessage() >>= message_matcher;
            }
            auto constexpr with_message( std::string_view message_to_match ) {
                using Detail::operator >>=;
                return *this >>= HasMessage() >>= StringMatchers::Equals(message_to_match);
            }

            template<typename ArgT>
            [[nodiscard]] constexpr auto lazy_match(ArgT&& f) const -> MatchResult {
                return lazy_bound_match(std::forward<ArgT>(f), Detail::AlwaysMatcher()).make_child_of(this);
            }

            template<typename BoundMatcherT>
            [[nodiscard]] constexpr auto lazy_bound_match(auto&& f, BoundMatcherT const& bound_matcher) const -> MatchResult {
                if constexpr( std::is_void_v<E> ) {
                    try {
                        f();
                        return false;
                    }
                    catch(...) {
                        return bound_matcher.match(std::current_exception())
                            .set_address(&bound_matcher)
                            .make_child_of(this);
                    }
                }
                else {
                    static_assert(Detail::IsEagerMatcher<BoundMatcherT, E>,
                        "The bound matcher must accept the type (or a super class of) that was detected as thrown");
                    try {
                        f();
                        return false;
                    }
                    catch(E& ex) {
                        return bound_matcher.match(ex)
                            .set_address(&bound_matcher)
                            .make_child_of(this);
                    }
                    catch(...) {
                        return false;
                    }
                }
                return false;
            }
            [[nodiscard]] auto describe() const -> std::string{
                if constexpr(std::is_void_v<E>)
                    return "throws()";
                else
                    return std::format("throws<{}>()", Detail::parse_templated_name("E"));
            }
        };

    } // namespace ExceptionMatchers

    namespace FloatMatchers {
        struct IsCloseTo {
            double target;

            [[nodiscard]] auto match(double value) const -> MatchResult {
                // !TBD: use better approach
                return std::fabs(value-target) < 10*std::numeric_limits<double>::epsilon();
            }
            [[nodiscard]] auto describe() const {
                return std::format("is_close_to({})", target);
            }
        };
    } // namespace FloatMatchers

    namespace VectorMatchers {
        template<typename T, typename AllocatorT>
        struct Equals {
            std::vector<T, AllocatorT> const& match_vec;

            [[nodiscard]] auto match(auto const& vec) const -> MatchResult {
                if (match_vec.size() != vec.size())
                    return false;
                return std::equal(match_vec.begin(), match_vec.end(), vec.begin());
            }
            [[nodiscard]] auto describe() const {
                return std::format("equals(vec)"); // !TBD
            }
        };
    }

    namespace Matchers {
        using StringMatchers::CaseSensitive;
        using StringMatchers::CaseInsensitive;

        template<class T>
        concept NotStringViewable = !std::is_convertible_v<T, std::string_view>;

        template<NotStringViewable T>
        auto equals(T& value) { return GenericMatchers::Equals<T>{value}; }

        template<typename CasePolicy=CaseSensitive>
        auto starts_with(std::string_view str) { return StringMatchers::StartsWith<CasePolicy>{str}; }

        template<typename CasePolicy=CaseSensitive>
        auto ends_with(std::string_view str) { return StringMatchers::EndsWith<CasePolicy>{str}; }

        template<typename CasePolicy=CaseSensitive>
        auto contains(std::string_view str) { return StringMatchers::Contains<CasePolicy>{str}; }

        template<typename CasePolicy=CaseSensitive>
        auto equals(std::string_view str) { return StringMatchers::Equals<CasePolicy>{str}; }

        inline auto is_close_to(double target) { return FloatMatchers::IsCloseTo{target}; }

        inline auto is_true() { static bool true_value = true; return equals(true_value); }
        inline auto is_false() { static bool false_value = false; return equals(false_value); }

        template<typename T, typename AllocatorT>
        auto equals(std::vector<T, AllocatorT> const& vec) { return VectorMatchers::Equals<T, AllocatorT>{vec}; }

        template<typename T, typename AllocatorT>
        auto equals(std::vector<T, AllocatorT>& vec) { return VectorMatchers::Equals<T, AllocatorT>{vec}; }

        template<typename E=void>
        using throws = ExceptionMatchers::Throws<E>;

        template<typename PredicateT>
        auto matches_predicate(PredicateT&& pred, std::string description = "predicate") {
            return GenericMatchers::MatchesPredicate<PredicateT>(std::forward<PredicateT>(pred), std::move(description));
        }

    } // namespace Matchers

} // namespace CatchKit


// Packed from catch23/include/catch23/internal_execution_nodes.h
namespace CatchKit::Detail {

    struct NodeId {
        std::string name;
        std::source_location location = std::source_location::current();

        // !TBD: We could have a NodeIdLite that has a string_view so we don't copy the strings
        // every time

        auto operator == (NodeId const& other) const -> bool {
            return location.line() == other.location.line()
                && location.column() == other.location.column()
                && location.file_name() == other.location.file_name();
        };
    };

    class ExecutionNodes;

    class ExecutionNode {
    public:
        enum class States {
            None, // Just added
            NotEntered, // Added on a previous cycle but not (yet) entered on this one
            Entered,
            EnteredButDoneForThisLevel,
            ExitedEarly, // through an early return or exception - including test cancellation
            HasIncompleteChildren,
            Incomplete, // Children are complete, but there are more local levels (e.g. generator values)
            Completed
        };

    private:
        friend class ExecutionNodes;

        NodeId id;
        ExecutionNodes* container = nullptr;

        ExecutionNode* parent = nullptr;
        std::vector<std::unique_ptr<ExecutionNode>> children;
        States state = States::None;

        auto get_current_node() -> ExecutionNode*;
        auto set_current_node(ExecutionNode* node);

    protected:
        const size_t size;
        size_t current_index = 0;

    public:
        explicit ExecutionNode( NodeId&& id, size_t size = 1 )
        :   id(std::move(id)),
            size(size)
        {}
        virtual ~ExecutionNode() = default;

        auto find_child(NodeId const& id) -> ExecutionNode*;

        auto add_child(std::unique_ptr<ExecutionNode>&& child) -> ExecutionNode& {
            child->parent = this;
            children.emplace_back( std::move(child) );
            return *children.back();
        }
        auto add_child(NodeId&& id) -> ExecutionNode&;

        [[nodiscard]] auto get_state() const { return state; }
        [[nodiscard]] auto get_parent() { return parent; }
        [[nodiscard]] auto get_parent_state() const { return parent ? parent->get_state() : States::None; }
        [[nodiscard]] auto get_size() const { return size; }
        [[nodiscard]] auto get_current_index() const { return current_index; }

        void reset();
        void reset_children();

        void enter();
        auto exit(bool early = false) -> States;
    };

    class ExecutionNodes {
        ExecutionNode root;
        ExecutionNode* current_node;
        friend class ExecutionNode;
    public:
        explicit ExecutionNodes(NodeId&& root_id)
        :   root(std::move(root_id)),
            current_node(&root)
        {
            root.container = this;
        }

        auto find_node(NodeId const& id) -> ExecutionNode* {
            return current_node->find_child(id);
        }
        auto add_node(std::unique_ptr<ExecutionNode>&& child) -> ExecutionNode&;
        auto add_node(NodeId&& id) -> ExecutionNode&;

        auto& get_root() { return root; }
    };

} // namespace CatchKit::Detail



// Packed from catch23/include/catch23/test_info.h
namespace CatchKit {

    struct TestInfo {
        std::source_location location;
        std::string name = {};
        std::string tags = {};
    };

} // namespace CatchKit


// Packed from catch23/include/catch23/reporter.h
namespace CatchKit {

    struct AssertionInfo {
        ResultType result;
        std::optional<ExpressionInfo> expression_info;
        std::string message;

        [[nodiscard]] auto passed() const { return result == ResultType::Pass; }
    };

    struct Counters {
        int passed_explicitly = 0;
        int failed_expectedly = 0;
        int failed = 0;

        [[nodiscard]] auto passed() const { return passed_explicitly + failed_expectedly; }

        [[nodiscard]] auto total() const { return passed() + failed; }

        [[nodiscard]] auto all_passed() const { return failed == 0; }

        auto& operator += ( Counters const& other ) {
            passed_explicitly += other.passed_explicitly;
            failed_expectedly += other.failed_expectedly;
            failed += other.failed;

            return *this;
        }

        friend auto operator + ( Counters const& lhs, Counters const& rhs ) {
            Counters result = lhs;
            result += rhs;
            return result;
        }
    };

    struct Reporter {
        virtual ~Reporter() = default;

        virtual auto report_on_what() const -> ReportOn = 0;

        virtual void on_test_start( TestInfo const& test_info ) = 0;
        virtual void on_test_end( TestInfo const& test_info, Counters const& assertions ) = 0;

        virtual void on_assertion_start( AssertionContext const& context ) = 0;
        virtual void on_assertion_end( AssertionContext const& context, AssertionInfo const& assertion_info ) = 0;
    };

} // namespace CatchKit


// Packed from catch23/include/catch23/test_result_handler.h
namespace CatchKit::Detail
{
    class TestCancelled {};

    class TestResultHandler : public ResultHandler {
        Reporter& reporter;
        AssertionContext current_context;
        ResultType last_result = ResultType::Unknown;
        ResultDisposition result_disposition = ResultDisposition::Abort;
        ExecutionNodes* execution_nodes = nullptr;

        std::vector<VariableCapture*> variable_captures;
        Counters assertions;

    public:
        explicit TestResultHandler(Reporter& reporter);

        auto operator=(TestResultHandler&&) = delete; // non-copyable, non-moveable

        void on_assertion_start( ResultDisposition result_disposition, AssertionContext&& context ) override;
        void on_assertion_result( ResultType result, std::optional<ExpressionInfo> const& expression_info, std::string_view message ) override;
        void on_assertion_end() override;

        void add_variable_capture( VariableCapture* capture ) override;
        void remove_variable_capture( VariableCapture* capture ) override;

        [[nodiscard]] auto get_reporter() -> Reporter& { return reporter; }
        [[nodiscard]] auto get_current_context() const -> AssertionContext const& { return current_context; }
        [[nodiscard]] auto passed() const { return last_result == CatchKit::ResultType::Pass; }
        [[nodiscard]] auto get_execution_nodes() const { return execution_nodes; }
        [[nodiscard]] auto get_assertion_counts() const { return assertions; }

        void reset_assertion_counts() { assertions = Counters(); }
        void set_execution_nodes( ExecutionNodes* nodes ) { execution_nodes = nodes; }
    };

    auto get_execution_nodes_from_result_handler(ResultHandler& handler) -> ExecutionNodes&;

} // namespace CatchKit::Detail

namespace CatchKit {

    using Detail::TestResultHandler;

} //namespace CatchKit


// Packed from catch23/include/catch23/sections.h
namespace CatchKit::Detail {

    struct SectionInfo {
        ExecutionNode& node;
        bool entered;

        ~SectionInfo();

        explicit operator bool() const noexcept { return entered; }
    };

    auto try_enter_section(ExecutionNodes& nodes, std::string_view name, std::source_location const& location = std::source_location::current()) -> SectionInfo;

} // namespace CatchKit::Detail

#define SECTION(name) if( auto section_info = try_enter_section(CatchKit::Detail::get_execution_nodes_from_result_handler(check.result_handler), name) )


// Packed from catch23/include/catch23/internal_test.h
namespace CatchKit::Detail {
    struct Checker;

    struct Test {
        std::function<void(Checker&, Checker&)> test_fun;
        TestInfo test_info;
    };
    std::vector<Test> const& get_all_tests();

    struct AutoReg {
        explicit AutoReg(Test&& test);
    };

} // CatchKit::Detail


// Packed from catchkit/include/catchkit/unique_name.h
#define CATCHKIT_INTERNAL_UNIQUE_NAME_CAT2( first, second ) first##second
#define CATCHKIT_INTERNAL_UNIQUE_NAME_CAT( first, second ) CATCHKIT_INTERNAL_UNIQUE_NAME_CAT2( first, second )
#define CATCHKIT_INTERNAL_UNIQUE_NAME( name ) CATCHKIT_INTERNAL_UNIQUE_NAME_CAT( name, __LINE__ )



// Packed from catch23/include/catch23/test.h
#define CATCH23_TEST_INTERNAL(fname, ...) \
    static void fname(CatchKit::Checker&, CatchKit::Checker&); \
    namespace{ CatchKit::Detail::AutoReg CATCHKIT_INTERNAL_UNIQUE_NAME( autoRegistrar ) ( { &fname, { std::source_location::current(), __VA_ARGS__ } } ); } /* NOLINT */ \
    CATCHKIT_WARNINGS_SUPPRESS_UNUSED_PARAMETER \
    static void fname(CatchKit::Checker& check, CatchKit::Checker& require ) \

#define TEST(...) CATCH23_TEST_INTERNAL(CATCHKIT_INTERNAL_UNIQUE_NAME(catch23_test), __VA_ARGS__)


// Packed from catch23/include/catch23/catch2_compat.h
#define TEST_CASE(...) CATCH23_TEST_INTERNAL(CATCHKIT_INTERNAL_UNIQUE_NAME(catch23_test), __VA_ARGS__)

// !TBD: these lose the expression decomposition, currently (which defeats the purpose)
#define CHECK_FALSE(...) CATCHKIT_ASSERT_THAT_INTERNAL( "CHECK_TRUE", check, __VA_ARGS__, is_false() )
#define REQUIRE_FALSE(...) CATCHKIT_ASSERT_THAT_INTERNAL( "REQUIRE_TRUE", require, __VA_ARGS__, is_false() )

#define SUCCEED(...) PASS(__VA_ARGS__)


// Packed from catch23/include/catch23/colour.h
namespace CatchKit {

    enum class Colours {
        Reset = 0,
        White = Reset,
        Red,
        Green,
        Blue,
        Cyan,
        Yellow,
        Grey,

        BoldRed,
        BoldGreen,
        BoldGrey,
        BoldWhite,
        BoldYellow,
        BoldNormal
    };

    struct ColourIntent {
        static Colours FileName;
        static Colours Warning;
        static Colours ResultError;
        static Colours ResultSuccess;
        static Colours ResultExpectedFailure;

        static Colours Error;
        static Colours Success;
        static Colours Skip;

        static Colours OriginalExpression;
        static Colours ReconstructedExpression;

        static Colours SecondaryText;
        static Colours Headers;
    };

    class TextColour {
    public:
        TextColour() = default;
        explicit TextColour(Colours initial_colour) { set(initial_colour); };
        ~TextColour();

        auto operator=(TextColour&&)  = delete; // non-moveable, non-copyable

        void set(Colours colour) const;
    };

} // namespace CatchKit


// Packed from catch23/include/catch23/console_reporter.h
namespace CatchKit {

    class ConsoleReporter : public Reporter {
        std::optional<TestInfo> lazy_test_info;
        ReportOn what_to_report_on;
        void lazy_print_test_header();

        Counters test_totals;
        Counters assertion_totals;

    public:
        explicit ConsoleReporter( ReportOn what_to_report_on = ReportOn::FailuresOnly )
        : what_to_report_on( what_to_report_on )
        {}

        auto report_on_what() const -> ReportOn override {
            return what_to_report_on;
        }

        void on_test_start( TestInfo const& test_info ) override;
        void on_test_end( TestInfo const& test_info, Counters const& assertions ) override;

        void on_assertion_start( AssertionContext const& context ) override;
        void on_assertion_end( AssertionContext const& context, AssertionInfo const& assertion_info ) override;

        void on_test_run_end();
    };

} // namespace CatchKit


// Packed from catch23/include/catch23/print.h
namespace CatchKit {

    template<typename ...Args>
    void print( Colours colour, std::format_string<Args...> fmt, Args&&... args ) {
        TextColour colourGuard(colour);
        std::print(fmt, std::forward<Args>(args)...);
    }
    template<typename ...Args>
    void println( Colours colour, std::format_string<Args...> fmt, Args&&... args ) {
        TextColour colourGuard(colour);
        std::println(fmt, std::forward<Args>(args)...);
    }

} // namespace CatchKit


// Packed from catch23/include/catch23/generator_node.h
namespace CatchKit {

    namespace Detail {

        template<typename G>
        concept IsSingleValueGenerator = requires(G g){ { g.generate() }; };

        template<typename G>
        concept IsMultiValueGenerator = requires(G const& g, size_t pos){ { g.generate_at(pos) }; };

        template<typename G>
        concept IsSizedGenerator = requires(G const& g, size_t pos){ { g.size(pos) } -> std::same_as<size_t>; };

        template<typename G>
        auto size_of(G const& generator, size_t default_size = 100) {
            if constexpr( IsMultiValueGenerator<G> ) {
                static_assert( !IsSizedGenerator<G>, "Generator has generate_at() but not size()");
                return generator.size();
            }
            else
                return default_size;
        }

        template<typename G>
        auto generate_at(G const& generator, size_t pos) {
            if constexpr( IsSingleValueGenerator<G> )
                return generator.generate();
            else if constexpr( IsMultiValueGenerator<G> )
                return generator.generate_at(pos);
            else
                return generate_value(generator);
        }

        constexpr size_t default_repetitions = 100; // Make this runtime configurable?

        // Typed generator holder node
        template<typename T>
        class GeneratorNode : public ExecutionNode {
            T generator;
            using GeneratedType = decltype(generate_at(generator, 0));
            std::vector<GeneratedType> values;

        public:
            explicit GeneratorNode( NodeId&& id, T&& gen )
            : ExecutionNode(std::move(id), size_of(gen, default_repetitions)), generator(std::move(gen)) {
                values.reserve(size);
                for(size_t i=0; i < size; ++i) {
                    values.emplace_back(generate_at(generator, i));
                }
            }

            GeneratedType& current_value() {
                assert(current_index < values.size());
                return values[current_index];
            }
            // !TBD shrink?
        };


        struct GeneratorAcquirer {
            ExecutionNodes& execution_nodes;
            NodeId id;
            ExecutionNode* generator_node;

            GeneratorAcquirer(Checker& checker, NodeId&& id)
            :   execution_nodes(get_execution_nodes_from_result_handler(checker.result_handler)),
                id(std::move(id)),
                generator_node(execution_nodes.find_node(this->id))
            {}

            template<typename T>
            void make_generator(T&& gen) {
                generator_node = &execution_nodes.add_node( std::make_unique<GeneratorNode<T>>(std::move(id), std::forward<T>(gen)) );
            }
            template<typename T>
            auto derived_node() {
                assert(generator_node != nullptr);
                generator_node->enter();
                return static_cast<GeneratorNode<T>*>(generator_node);
            }
        };

    } // namespace Detail

} // namespace CatchKit



// Packed from catch23/include/catch23/random.h
namespace CatchKit::Detail {

    // !TBD This is a placeholder for a proper implementation
    // In particular the non-portable distribution is an issue
    // Should probably borrow from Martin's work on Catch2

    template<typename T>
    concept IsBuiltInNumeric = std::integral<T> || std::floating_point<T>;

    // Returns a number between from and to, inclusive
    template<IsBuiltInNumeric NumberT>
    auto generate_random_number(NumberT from, NumberT to) -> NumberT {
        std::random_device random_device;
        std::mt19937 mt(random_device());
        if constexpr(std::integral<NumberT>)
            return std::uniform_int_distribution<NumberT>(from, to)(mt);
        else
            return std::uniform_real_distribution<NumberT>(from, to)(mt);
    }

} // namespace CatchKit::Detail


// Packed from catch23/include/catch23/generators.h
namespace CatchKit {

    namespace Detail {

        // To provide your own generators, either:
        // 1. specialise values_of for your type and generate_value for valuesOf<your type>, or
        // 2. for something more general/ operators on multiple values, specialise size_of and generate_at

        template<typename T> struct values_of {}; // Specialise this for your own types


        // Adapter to specify number of repetitions:

        template<typename T>
        struct multiple_values {
            size_t multiple;
            values_of<T> value_generator;

            auto generate_at(size_t) const { return value_generator.generate(); }
            auto size() const { return multiple; }
        };


        template<typename T>
        constexpr auto operator, (size_t multiple, values_of<T>&& values) {
            return multiple_values<T>{ multiple, std::move(values) };
        }


        // Numeric (int or real) generators:

        template<IsBuiltInNumeric T>
        struct values_of<T> {
            T from {};
            T up_to = std::numeric_limits<T>::max();

            [[nodiscard]] auto generate() const { return generate_random_number(from, up_to); }

            // Given a starting value, try different strategies to produce a simpler value that might
            // also fail. If it still passes this function will be called again with an incremented
            // strategy number, and this will repeat until either a failure is found
            // or the function returns an empty optional

            // Could use coroutines to "simplify" this?
            auto shrink(T value, int strategy_index) -> std::optional<T>;
        };

        template<IsBuiltInNumeric T>
        struct inclusive_range_of {
            T from {};
            T to = std::numeric_limits<T>::max();

            [[nodiscard]] auto generate_at(size_t index) const { return from + index; }
            auto size() const { return to - from; }
        };

        // String generator:

        namespace Charsets {
            extern std::string const lcase;
            extern std::string const ucase;
            extern std::string const all_alpha;
            extern std::string const numbers;
            extern std::string const alphanumeric;
            extern std::string const word_chars;
            extern std::string const symbols;
            extern std::string const printable_ascii;
        }

        template<>
        struct values_of<std::string> {
            size_t min_len = 0;
            size_t max_len = 65;
            std::string_view charset = Charsets::word_chars; // Must be from string literal

            [[nodiscard]] auto generate() const -> std::string;
        };


        // Generate specific values:

        template<typename T>
        struct from_values {
            std::vector<T> values;

            auto generate_at(size_t pos) const { return values[pos]; }
            auto size() const { return values.size(); }

        };
        template<typename T>
        from_values(std::initializer_list<T> values) -> from_values<T>;

        // Vector generators

        template<typename T>
        struct values_of<std::vector<T>> {
            size_t min_size = 0;
            size_t max_size = 65;
            values_of<T> value_generator;

            [[nodiscard]] auto generate() const {
                std::vector<T> values( generate_random_number(min_size, max_size) );
                std::ranges::generate(values, [generator=value_generator]{ return generator.generate(); });
                return values;
            }
        };

    } // namespace Detail

    namespace Generators {

        namespace Charsets { using namespace Detail::Charsets; }

        // Built in matchers
        using Detail::values_of;
        using Detail::from_values;
        using Detail::inclusive_range_of;

    } // namespace Generators

} // namespace CatchKit


#define GENERATE(...) \
    [&check]{ using namespace CatchKit::Generators; \
        CatchKit::Detail::GeneratorAcquirer acquirer(check, {#__VA_ARGS__}); \
        if( !acquirer.generator_node ) acquirer.make_generator((__VA_ARGS__)); \
        return acquirer.derived_node<decltype((__VA_ARGS__))>(); \
    }()->current_value()



// Packed from catch23/include/catch23/local_test.h
namespace CatchKit {

    struct FullAssertionInfo {
        AssertionContext context;
        AssertionInfo info;
    };

    class MetaTestReporter : public Reporter {
        ReportOn what_to_report_on;

    public:
        explicit MetaTestReporter( ReportOn what_to_report_on = ReportOn::AllResults )
        : what_to_report_on( what_to_report_on )
        {}

        auto report_on_what() const -> ReportOn override {
            return what_to_report_on;
        }

        void on_test_start( TestInfo const& ) override {}
        void on_test_end( TestInfo const&, Counters const& ) override {}

        void on_assertion_start( AssertionContext const& ) override {}
        void on_assertion_end( AssertionContext const& context, AssertionInfo const& assertion_info ) override {
            results.emplace_back(context, assertion_info);
        }
        std::vector<FullAssertionInfo> results;
    };

    class MetaTestRunner {
        MetaTestReporter reporter;
        TestResultHandler handler;

        std::string name;
        std::source_location location;

    public:
        explicit MetaTestRunner(std::string name = "local test", std::source_location location = std::source_location::current());
        auto run( Detail::Test const& test ) && -> std::vector<FullAssertionInfo>;
        auto operator << ( std::invocable<Checker&, Checker&> auto const& test_fun ) && {
            return std::move(*this).run(Detail::Test{test_fun, {location, std::move(name)}});
        }
    };

} // namespace CatchKit

#define LOCAL_TEST(...) CatchKit::MetaTestRunner(__VA_ARGS__) << [](CatchKit::Checker& check, CatchKit::Checker&)


// Packed from catch23/include/catch23/runner.h
namespace CatchKit::Detail {

    template<typename R, typename T>
    concept range_of = std::ranges::range<R> &&
                       std::same_as<std::ranges::range_value_t<R>, T>;

    void run_test( Test const& test, TestResultHandler& test_handler );

    void run_tests( range_of<Test> auto const& tests, Reporter& reporter ) {
        TestResultHandler test_handler( reporter );

        for( auto&& test : tests) {
            // !TBD: this skips hidden tests until we do proper tag parsing
            if( test.test_info.tags.find("[.") != std::string::npos )
                continue;

            run_test(test, test_handler);
        }
    }

} // namespace CatchKit::Detail


// Packed from catch23/include/catch23/main.h
#define CATCH23_MAIN_MIN(...) \
    int main() { \
        using namespace CatchKit; \
        auto reporter = ConsoleReporter(__VA_ARGS__); \
        run_tests(Detail::get_all_tests(), reporter); \
        reporter.on_test_run_end(); \
    }

// From source files:
#ifdef CATCHKIT_IMPL

// System includes (for impl):
#include <map>
#include <sstream>


// Packed from catchkit/src/assert_result_handler.cpp
namespace CatchKit::Detail {

    void AssertResultHandler::on_assertion_start( ResultDisposition result_disposition, AssertionContext&& context ) {
        current_context = std::move(context);
        this->result_disposition = result_disposition;
    }

    void AssertResultHandler::on_assertion_result( ResultType result, std::optional<ExpressionInfo> const& expression_info, std::string_view message ) {;
        last_result = result;

        // !TBD When we can use stacktrace do something like this:
        // https://godbolt.org/z/jM4TnaMEW

        auto os = stdout;
        if (last_result != ResultType::Pass )
            os = stderr;

        std::println(os, "{}:{}:{}: in function '{}'",
                current_context.location.file_name(),
                current_context.location.line(),
                current_context.location.column(),
                current_context.location.function_name());
        std::string_view macro_name = current_context.macro_name;
        if ( macro_name.empty() )
            macro_name = "assertion";
        if ( !current_context.original_expression.empty() )
            std::println(os, "{} {} for expression:\n\t{}",
                macro_name, (result == ResultType::Pass) ? "passed" : "failed",
                current_context.original_expression);
        else
            std::println(os, "{} {}",
                macro_name, (result == ResultType::Pass) ? "passed" : "failed");
        switch( result ) {
            case ResultType::UnexpectedException:
                std::println(os, "due to an unexpected exception");
                break;
            case ResultType::MissingException:
                std::println(os, "due to a missing exception");
                break;
            default:
                if(expression_info)
                    std::println(os, "with expansion:\n\t{}", *expression_info );
                break;
        }
        if (!message.empty()) {
            std::println(os, "with message:\n\t{}", message);
        }
    }
    void AssertResultHandler::on_assertion_end() {
        if ( last_result != ResultType::Pass && result_disposition == ResultDisposition::Abort ) {
            std::terminate();
        }
    }

} // namespace CatchKit::Detail

// Packed from catchkit/src/assertion_context.cpp
namespace CatchKit::Detail {

    auto AssertionContext::combine_messages( std::string_view additional_message ) -> std::string {
        if(!message.empty()) {
            if(!additional_message.empty())
                return std::string(message) + "\n" + std::string(additional_message);
            return std::string(message);
        }
        if(!additional_message.empty())
            return std::string(additional_message);
        return {};
    }

} // namespace CatchKit::Detail
// Packed from catchkit/src/checker.cpp
namespace {
    CatchKit::Detail::AssertResultHandler default_assertion_handler;
    constinit CatchKit::Detail::ResultHandler* current_assertion_handler = &default_assertion_handler;
}

constinit CatchKit::Checker check(default_assertion_handler, CatchKit::ResultDisposition::Continue);
constinit CatchKit::Checker require(default_assertion_handler, CatchKit::ResultDisposition::Abort);

namespace CatchKit::Detail {

    // !TBD Do we need to return the old one so it can be set back later?
    // This would probably change to being a pointer
    void set_current_assertion_handler( AssertResultHandler& handler ) {
        current_assertion_handler = &handler;
    }

    auto Checker::operator()(std::string_view message, std::source_location assertion_location) -> Asserter {
        return operator()(AssertionContext{{}, {}, message, assertion_location});
    }

    auto Checker::operator()(AssertionContext&& context) -> Asserter {
        result_handler.on_assertion_start(result_disposition, std::move(context));
        return Asserter{*this};
    }

} // namespace CatchKit::Detail

// Packed from catchkit/src/exceptions.cpp
namespace CatchKit::Detail {

    std::string unknown_exception_message = "<unknown exception type>";

    [[nodiscard]] auto get_exception_message( std::exception const& ex ) -> std::string {
        return ex.what();
    }
    [[nodiscard]] auto get_exception_message( std::string const& str ) -> std::string {
        return str;
    }

    [[nodiscard]] auto get_exception_message( std::exception_ptr const& ex ) -> std::string {
        std::string message;
        try {
            std::rethrow_exception(ex);
        }
        catch(std::exception& e) {
            return get_exception_message(e);
        }
        catch (std::string& s) {
            return get_exception_message(s);
        }
        catch(...) {
            // !TBD: registry for custom exception translations
            return unknown_exception_message;
        }
    }

} // namespace CatchKit::Detail
// Packed from catchkit/src/expression_info.cpp
std::format_context::iterator std::formatter<CatchKit::Detail::ExpressionInfo>::format(const CatchKit::Detail::ExpressionInfo& expr, std::format_context& ctx) const {
    if( expr.op == CatchKit::Detail::Operators::None )
        return std::format_to(ctx.out(), "{}", expr.lhs);
    else
        return std::format_to(ctx.out(), "{} {} {}", expr.lhs, expr.op_str, expr.rhs);
}

// Packed from catchkit/src/matchers.cpp
namespace CatchKit {

    // !TBD: test the others
    static_assert(Detail::IsMatcher<GenericMatchers::Equals<bool>>);
    static_assert(Detail::IsEagerMatcher<ExceptionMatchers::HasMessage>);
    static_assert(Detail::IsMatcher<ExceptionMatchers::HasMessage>);

    namespace StringMatchers {

        bool CaseSensitive::equal(std::string_view str1, std::string_view str2) {
            return str1 == str2;
        }
        bool CaseSensitive::find(std::string_view str, std::string_view substr) {
            return str.find(substr) != std::string_view::npos;
        }
        bool CaseInsensitive::equal(std::string_view str1, std::string_view str2) {
            return std::ranges::equal(str1, str2,
                [](char a, char b) {
                    return std::tolower(a) == std::tolower(b);
                });
        }
        bool CaseInsensitive::find(std::string_view str, std::string_view substr) {
            return !std::ranges::search(str, substr,
                [](char a, char b) {
                    return std::tolower(a) == std::tolower(b);
                }).empty();
        }

    } // namespace StringMatchers

    namespace Detail {
        void add_subexpressions( std::vector<SubExpressionInfo>& sub_expressions, MatchResult const& results, void const* matcher_address, std::string const& description ) {
            if( auto it = std::ranges::find( results.child_results, matcher_address, &SubExpression::matcher_address ); it != results.child_results.end() )
                sub_expressions.emplace_back(description, it->result);
            else if( results.matcher_address == matcher_address )
                sub_expressions.emplace_back(description, results.result);
        }
    } // namespace Detail

} // namespace CatchKit
// Packed from catchkit/src/result_handler.cpp
namespace CatchKit::Detail
{
    ResultHandler::~ResultHandler() = default;

} // namespace CatchKit::Detail
// Packed from catchkit/src/stringify.cpp
namespace CatchKit::Detail {

    auto parse_templated_name( std::string const& templated_name, std::string_view function_name ) -> std::string_view {
        if( auto start = function_name.find(templated_name + " = "); start != std::string_view::npos ) {
            start += templated_name.size() + 3;
            if( auto end = function_name.find_first_of(",;", start); end != std::string_view::npos )
                return function_name.substr(start, end-start);
        }
        return {};
    }
    auto parse_templated_name( std::string const& templated_name, std::source_location location ) -> std::string_view {
        return parse_templated_name( templated_name, location.function_name() );
    }
    auto parse_enum_name_from_function(std::string_view function_name, bool fully_qualified) -> std::string_view {
        auto qualified_enum_name = parse_templated_name("candidate", function_name);
        if( fully_qualified )
            return qualified_enum_name;
        if( auto last_colon = qualified_enum_name.find_last_of(':'); last_colon != std::string_view::npos )
            return qualified_enum_name.substr(last_colon+1);
        return {};
    }
    auto unknown_enum_to_string(size_t enum_value) -> std::string {
        return std::format("<unknown enum value: {}>", enum_value);
    }

    auto pointer_to_string(void const* p) -> std::string {
        return std::format("0x{:0>8}", reinterpret_cast<intptr_t>(p));
    }

} // namespace CatchKit::Detail

// Packed from catchkit/src/variable_capture.cpp
namespace CatchKit::Detail {

    VariableCapture::VariableCapture(std::string_view name, std::string_view type, Checker& checker)
    : name(name), type(type), result_handler(checker.result_handler) {
        result_handler.add_variable_capture(this);
    }
    VariableCapture::~VariableCapture() {
        result_handler.remove_variable_capture(this);
    }

} // namespace CatchKit::Detail

// Packed from catch23/src/colour.cpp
#if !(defined(__DJGPP__) && defined(__STRICT_ANSI__))
#  include <unistd.h>
#endif

namespace CatchKit {
    namespace Detail {
        bool is_colour_available() {
            static bool colour_available =
#if !(defined(__DJGPP__) && defined(__STRICT_ANSI__))
                isatty(STDOUT_FILENO)
#endif
#if defined(CATCHKIT_PLATFORM_APPLE)
            && !isDebuggerActive()
#endif
            ;
            return colour_available;
        }
    } // namespace Detail

    TextColour::~TextColour() {
        set(Colours::Reset);
    }

    void TextColour::set( Colours colour ) const {
        if ( Detail::is_colour_available() ) {
            std::print("\o{33}[0;{}m", [colour]() {
                switch( colour )
                {
                    using enum Colours;
                    case Reset:     return "0;39";
                    case Red:       return "0;31";
                    case Green:     return "0;32";
                    case Blue:      return "0;34";
                    case Cyan:      return "0;36";
                    case Yellow:    return "0;33";
                    case Grey:      return "1;30";

                    case BoldGrey:      return "0;37";
                    case BoldRed:       return "1;31";
                    case BoldGreen:     return "1;32";
                    case BoldWhite:     return "1;37";
                    case BoldYellow:    return "1;33";
                    case BoldNormal:    return "1;39";
                    default:
                        assert(false);
                        std::unreachable();
                }
            }());
        }
    }

    Colours ColourIntent::FileName = Colours::BoldGrey;
    Colours ColourIntent::ResultError = Colours::BoldRed;
    Colours ColourIntent::ResultSuccess = Colours::BoldGreen;
    Colours ColourIntent::ResultExpectedFailure = Warning;

    Colours ColourIntent::Error = Colours::BoldRed;
    Colours ColourIntent::Success = Colours::Green;
    Colours ColourIntent::Warning = Colours::BoldYellow;
    Colours ColourIntent::Skip = Colours::BoldGrey;

    Colours ColourIntent::OriginalExpression = Colours::Cyan;
    Colours ColourIntent::ReconstructedExpression = Colours::BoldYellow;

    Colours ColourIntent::SecondaryText = Colours::BoldWhite;
    Colours ColourIntent::Headers = Colours::White;

} // namespace CatchKit

// Packed from catch23/src/console_reporter.cpp
namespace CatchKit {

    constexpr int console_width = 80; // !TBD: detect/ make configurable


    void print_totals_divider(Counters const& totals) {
        if (totals.total() > 0) {
            int passed_segments = console_width * totals.passed() / totals.total();
            int failed_segments = console_width * totals.failed / totals.total();
            if( passed_segments + failed_segments < console_width ) {
                if( passed_segments > failed_segments )
                    failed_segments++;
                else
                    passed_segments++;
            }

            print( ColourIntent::ResultError, "{}", std::string( failed_segments, '=' ) );
            print( ColourIntent::ResultSuccess, "{}", std::string( passed_segments, '=' ) );
            std::println();
        }
    }

    void ConsoleReporter::lazy_print_test_header() {
        if( lazy_test_info ) {
            std::println("-------------------------------------------------------------------------------");
            println(ColourIntent::Headers, "TEST: {}", lazy_test_info->name);
            std::println("{}:{}",
                    lazy_test_info->location.file_name(),
                    lazy_test_info->location.line());
            std::println("...............................................................................\n");
            lazy_test_info.reset();
        }
    }
    void ConsoleReporter::on_test_start( TestInfo const& test_info ) {
        lazy_test_info = test_info;
    }
    void ConsoleReporter::on_test_end( TestInfo const&, Counters const& assertions ) {
        if( assertions.failed == 0 )
            test_totals.passed_explicitly++;
        else
            test_totals.failed++;
        assertion_totals += assertions;
    }

    void ConsoleReporter::on_assertion_start( AssertionContext const& ) {
    }
    void ConsoleReporter::on_assertion_end( AssertionContext const& context, AssertionInfo const& assertion_info ) {
        lazy_print_test_header();
        println( assertion_info.passed() ? ColourIntent::Success : ColourIntent::Error,
                "{}:{}:{}: {}",
                context.location.file_name(),
                context.location.line(),
                context.location.column(),
                assertion_info.passed() ? "👍 PASSED" : "❌ FAILED");

        if( !context.original_expression.empty() )
            std::println( "for expression:" );

        if( context.macro_name.empty() ) {
            if( !context.original_expression.empty() )
                println( ColourIntent::OriginalExpression, "  {}", context.original_expression );
        }
        else {
            if( !context.original_expression.empty() )
                println( ColourIntent::OriginalExpression, "  {}( {} )", context.macro_name, context.original_expression );
            else
                println( ColourIntent::OriginalExpression, "  for {}", context.macro_name );
        }

        switch( assertion_info.result ) {
        case ResultType::UnexpectedException:
            std::println("due to an unexpected exception");
            break;
        case ResultType::MissingException:
            std::println("due to a missing exception");
            break;
        default:
            if( assertion_info.expression_info ) {
                std::println("with expansion:");
                auto const& expr_info = *assertion_info.expression_info;
                print( ColourIntent::ReconstructedExpression, "  {}", expr_info );
                if( !expr_info.sub_expressions.empty() ) {
                    std::println( " because:");
                    for(auto const& sub_expr : expr_info.sub_expressions) {
                        if( sub_expr.result )
                            std::print("    ✅ ");
                        else
                            std::print("    ❌ ");
                        print( ColourIntent::ReconstructedExpression, "{} ", sub_expr.description );
                        if( sub_expr.result )
                            std::println("matched");
                        else
                            std::println("failed to match");
                    }
                }
                std::println();
            }
            break;
        }
        if (!assertion_info.message.empty()) {
            std::println("with message:");
            println(ColourIntent::SecondaryText, "  {}", assertion_info.message);
        }
    }

    void ConsoleReporter::on_test_run_end() {
        print_totals_divider(test_totals);

        if ( test_totals.total() == 0 ) {
            println( ColourIntent::Warning, "No tests ran" );
            return;
        }

        if ( assertion_totals.total() > 0 && test_totals.all_passed() ) {
            println( ColourIntent::ResultSuccess, "All tests passed ({} assertion(s) in {} tests)",
                assertion_totals.total(), test_totals.total() );
            return;
        }

        auto print_summary = [](Counters const& counts, std::string const& label) {

            std::print("{}: {}", label, counts.total() );
            print( Colours::BoldGrey, " | " );
            if( counts.passed() > 0) {
                print( ColourIntent::ResultSuccess, "{} passed", counts.passed() );
                if( counts.failed > 0 )
                    print( Colours::BoldGrey, " | " );
            }
            if( counts.failed > 0) {
                print( ColourIntent::ResultError, "{} failed", counts.failed );
            }
            std::println();
        };
        print_summary(test_totals, "test cases");
        print_summary(assertion_totals, "assertions");
    }

} // namespace CatchKit
// Packed from catch23/src/generators.cpp
namespace CatchKit::Detail {

    namespace Charsets {
        std::string const lcase = "abcdefghijklmnopqrstuvwxyz";
        std::string const ucase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        std::string const all_alpha = lcase + ucase;
        std::string const numbers = "01234567890";
        std::string const alphanumeric = all_alpha + numbers;
        std::string const word_chars = alphanumeric + " ";
        std::string const symbols = "!@£$%^&*()-=_+[]{};'\\\\:\\\"|,./<>?`~";
        std::string const printable_ascii = word_chars + symbols;
    }


    auto values_of<std::string>::generate() const -> std::string {
        auto len = generate_random_number(min_len, max_len);
        std::string str;
        str.resize(len);
        for(size_t i = 0; i < len; ++i)
            str[i] = charset[generate_random_number<size_t>(0, charset.length()-1)];
        return str;
    }

} // namespace CatchKit::Generators::Detail

// Packed from catch23/src/internal_execution_nodes.cpp
namespace CatchKit::Detail {

    auto ExecutionNode::get_current_node() -> ExecutionNode* {
        assert(container);
        return container->current_node;
    }
    auto ExecutionNode::set_current_node(ExecutionNode* node) {
        assert(container);
        return container->current_node = node;
    }

    auto ExecutionNode::find_child(NodeId const& id) -> ExecutionNode* {
        for(auto const& child : children) {
            if(child->id == id)
                return child.get();
        }
        return nullptr;
    }

    auto ExecutionNode::add_child(NodeId&& id) -> ExecutionNode& {
        return add_child( std::make_unique<ExecutionNode>(std::move(id)) );
    }

    void ExecutionNode::reset() {
        if( state != States::NotEntered ) {
            state = States::NotEntered;
            current_index = 0;
            reset_children();
        }
    }
    void ExecutionNode::reset_children() {
        for(auto const& child : children) {
            child->reset();
        }
    }

    void ExecutionNode::enter() {
        assert(state != States::Entered && state != States::Completed);
        state = States::Entered;
        set_current_node(this);
    }
    auto ExecutionNode::exit(bool early) -> States {
        assert(state == States::Entered || state == States::EnteredButDoneForThisLevel);

        if(parent) {
            assert(parent->state == States::Entered || parent->state == States::EnteredButDoneForThisLevel);
            parent->state = States::EnteredButDoneForThisLevel;
        }
        for(auto const& child : children) {
            if( child->state == States::Entered || child->state == States::EnteredButDoneForThisLevel )
                child->exit();
            if( child->state != States::Completed && child->state != States::NotEntered ) {
                state = States::HasIncompleteChildren;
            }
            if( child->state == States::ExitedEarly )
                child->state = States::Completed;
        }
        if( get_current_node() == this ) {
            set_current_node(parent);
        }

        if( state == States::HasIncompleteChildren )
            return state;

        if( ++current_index != size ) {
            reset_children();
            return state = States::Incomplete;
        }

        reset_children();
        if( early )
            return state = States::ExitedEarly;

        return state = States::Completed;
    }

    auto ExecutionNodes::add_node(std::unique_ptr<ExecutionNode>&& child) -> ExecutionNode& {
        child->container = this;
        return current_node->add_child(std::move(child));
    }

    auto ExecutionNodes::add_node(NodeId&& id) -> ExecutionNode& {
        assert(find_node(id) == nullptr);
        auto& new_node = current_node->add_child(std::move(id));
        new_node.container = this;
        return new_node;
    }

} // namespace CatchKit::Detail

// Packed from catch23/src/internal_test.cpp
namespace CatchKit::Detail {
    std::vector<Test> tests;
    std::vector<Test> const& get_all_tests() { return tests; }

    AutoReg::AutoReg(Test&& test) {
        tests.emplace_back(std::move(test));
    }
}

// Packed from catch23/src/local_test.cpp
namespace CatchKit {
    MetaTestRunner::MetaTestRunner( std::string name, std::source_location location )
    :   handler( reporter ),
        name(std::move(name)),
        location(location)
    {}

    auto MetaTestRunner::run( Detail::Test const& test ) && -> std::vector<FullAssertionInfo> {
        run_test(test, handler);
        return std::move(reporter.results);
    }

} // namespace CatchKit
// Packed from catch23/src/runner.cpp
namespace CatchKit::Detail {

    void run_test( Test const& test, TestResultHandler& test_handler ) {
        Reporter& reporter = test_handler.get_reporter();

        ExecutionNodes execution_nodes({test.test_info.name, test.test_info.location});
        auto& root_node = execution_nodes.get_root();
        test_handler.set_execution_nodes(&execution_nodes);

        do {
            root_node.enter();
            assert(root_node.get_state() != ExecutionNode::States::Completed);

            reporter.on_test_start(test.test_info);

            Checker check{
                .result_handler=test_handler,
                .result_disposition=ResultDisposition::Continue };
            Checker require{
                .result_handler=test_handler,
                .result_disposition=ResultDisposition::Abort };

            try {
                test.test_fun(check, require);
            }
            catch( TestCancelled ) {
                // std::println("  *** aborted"); // !TBD
            }
            catch( ... ) {
                // We need a new context because the old one had string_views to outdated data
                // - we want to preserve the last known source location, though
                AssertionContext context{
                    .macro_name = "",
                    .original_expression = "* unknown line after the reported location *",
                    .message = {},
                    .location = test_handler.get_current_context().location };
                test_handler.on_assertion_start( ResultDisposition::Continue, std::move(context) );
                test_handler.on_assertion_result( ResultType::UnexpectedException, {}, get_exception_message(std::current_exception()) );
            }
            root_node.exit();

            reporter.on_test_end(test.test_info, test_handler.get_assertion_counts() );
            test_handler.reset_assertion_counts();
        }
        while(root_node.get_state() != ExecutionNode::States::Completed);

        test_handler.set_execution_nodes(nullptr);
    }

} // namespace CatchKit::Detail
// Packed from catch23/src/sections.cpp
namespace CatchKit::Detail {

    SectionInfo::~SectionInfo() {
        if( entered )
            node.exit( std::uncaught_exceptions() > 0 );
    }

    auto try_enter_section(ExecutionNodes& nodes, std::string_view name, std::source_location const& location) -> SectionInfo {
        // !TBD: avoid always copying the string
        auto node = nodes.find_node({std::string(name), location});
        if( !node )
            node = &nodes.add_node({std::string(name), location});

        // Don't enter if we've already entered a previous peer node
        // or if this node has already been completed
        if( node->get_parent_state() == ExecutionNode::States::EnteredButDoneForThisLevel ||
            node->get_state() == ExecutionNode::States::Completed ) {
            return SectionInfo{ *node, false };
        }
        node->enter();
        return SectionInfo{ *node, true };
    }

} // namespace CatchKit::Detail

// Packed from catch23/src/test_result_handler.cpp
namespace CatchKit::Detail {

    TestResultHandler::TestResultHandler(Reporter& reporter)
    :   ResultHandler(reporter.report_on_what()),
        reporter(reporter)
    {}

    void TestResultHandler::on_assertion_start( ResultDisposition result_disposition, AssertionContext&& context ) {
        current_context = std::move(context);
        this->result_disposition = result_disposition;
        reporter.on_assertion_start( context );
    }

    void TestResultHandler::on_assertion_result( ResultType result, std::optional<ExpressionInfo> const& expression_info, std::string_view message ) {
        if( result == ResultType::Pass )
            assertions.passed_explicitly++;
        else
            assertions.failed++;

        last_result = result;
        // !TBD: We should need to check this again
        // - go back to having two on_assertion_result methods - one that takes just a result,
        // the other takes the full, expanded, data (probably no need for optional)
        if( report_on == ReportOn::AllResults || result != ResultType::Pass ) {
            if( !message.empty() ) {
                // Attempt to string out an inline message
                // note: this is quite brittle, so if it seems to have stopped working
                // check that this logic still matches usage
                if( auto pos = current_context.original_expression.find(message); pos != std::string::npos ) {
                    if( pos > 3 && current_context.original_expression[pos-3] == ',' )
                        current_context.original_expression = current_context.original_expression.substr( 0, pos-3 );
                }
            }

            std::string full_message(message);

            // Add in any captured variables
            // !TBD: improve formatting - or should we pass this through in a more fine grained way to the reporter?
            if( !variable_captures.empty() ) {
                if( !full_message.empty() )
                    full_message += "\nwith";
                full_message += "captured variables:";
                for( auto var : variable_captures ) {
                    full_message += std::format("\n    {} : {} = {}", var->name, var->type, var->get_value() );
                }
            }
            reporter.on_assertion_end(current_context, AssertionInfo{ result, expression_info, full_message } );
        }
    }

    void TestResultHandler::on_assertion_end() {
        if( last_result != ResultType::Pass && result_disposition == ResultDisposition::Abort ) {
            throw TestCancelled();
        }
    }

    void TestResultHandler::add_variable_capture( VariableCapture* capture ) {
        variable_captures.push_back(capture);
    }
    void TestResultHandler::remove_variable_capture( VariableCapture* capture ) {
        std::erase(variable_captures, capture);
    }

    auto get_execution_nodes_from_result_handler(ResultHandler& handler) -> ExecutionNodes& {
        assert(dynamic_cast<TestResultHandler*>(&handler) != nullptr);
        auto execution_nodes = static_cast<TestResultHandler&>(handler).get_execution_nodes();
        assert(execution_nodes);
        return *execution_nodes;
    }

} // namespace CatchKit::Detail
#endif // CATCHKIT_IMPL

#endif // CATCH23_PACKED_H_INCLUDED
